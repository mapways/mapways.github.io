<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wayfinder Studio Enterprise</title>
    
    <!-- React (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    colors: { brand: { 500: '#3b82f6', 600: '#2563eb', 700: '#1d4ed8' } }
                }
            }
        }
    </script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- FIREBASE V9 MODULES -->
    <script type="importmap">
        {
            "imports": {
                "firebase/app": "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js",
                "firebase/firestore": "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js",
                "firebase/auth": "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js"
            }
        }
    </script>

    <script type="module">
        import { initializeApp } from "firebase/app";
        import { getFirestore, doc, setDoc, getDoc, getDocs, deleteDoc, collection, query, where, serverTimestamp } from "firebase/firestore";
        import { getAuth, onAuthStateChanged } from "firebase/auth";

        // --- YOUR CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyDWJ5qVnsA3rWvfkc0-_cIyfwLHEZNMuxE",
            authDomain: "wayfinder-app-a2565.firebaseapp.com",
            projectId: "wayfinder-app-a2565",
            storageBucket: "wayfinder-app-a2565.firebasestorage.app",
            messagingSenderId: "770872636942",
            appId: "1:770872636942:web:f342a0d96de313a19a6e5f",
            measurementId: "G-W7BXXBPLGX"
        };

        try {
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            const auth = getAuth(app);

            window.db = db;
            window.auth = auth;
            window.setDoc = setDoc;
            window.getDoc = getDoc;
            window.getDocs = getDocs;
            window.deleteDoc = deleteDoc;
            window.doc = doc;
            window.collection = collection;
            window.query = query;
            window.where = where;
            window.serverTimestamp = serverTimestamp;
            window.IMGBB_API_KEY = "d3c464ab1b35134225f0bf7787c09d16";
            
            onAuthStateChanged(auth, (user) => {
                window.dispatchEvent(new CustomEvent('firebase-auth-initialized', { detail: user }));
            });

        } catch (err) {
            console.error("Firebase Init Error", err);
        }
    </script>

    <style>
        body { background-color: #f1f5f9; overflow: hidden; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .cursor-pan { cursor: grab; }
        .cursor-panning { cursor: grabbing; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.2s ease-out forwards; }
        .path-line { stroke-dasharray: 10; animation: dash 1s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -20; } }
        .nav-item.active { background-color: #e2e8f0; color: #2563eb; }
    </style>
</head>
<body>
    <div id="root" class="h-screen w-screen flex flex-col">
        <div id="loading-fallback" class="h-full flex items-center justify-center text-slate-400">
            <i class="fas fa-spinner fa-spin text-4xl"></i>
            <span class="ml-3">Loading Studio...</span>
        </div>
    </div>

    <!-- MAIN APPLICATION SCRIPT -->
    <script type="text/babel" data-presets="react,typescript">
        const { useState, useRef, useEffect, useCallback } = React;

        // --- AUTH HOOK ---
        function useAuthStatus() {
            const [user, setUser] = useState(null);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const handleAuthInit = (e) => {
                    setUser(e.detail);
                    setLoading(false);
                };
                window.addEventListener('firebase-auth-initialized', handleAuthInit);
                if (window.auth) {
                    const unsubscribe = window.auth.onAuthStateChanged((u) => {
                        setUser(u);
                        setLoading(false);
                        window.removeEventListener('firebase-auth-initialized', handleAuthInit);
                    });
                    return () => unsubscribe();
                }
                return () => window.removeEventListener('firebase-auth-initialized', handleAuthInit);
            }, []);
            return { user, loading };
        }

        // --- HISTORY HOOK (Undo/Redo) ---
        function useHistory(initialState) {
            const [history, setHistory] = useState([initialState]);
            const [index, setIndex] = useState(0);

            const setState = (newState) => {
                const current = history[index];
                if (JSON.stringify(current) === JSON.stringify(newState)) return;
                const newHistory = history.slice(0, index + 1);
                newHistory.push(newState);
                if(newHistory.length > 30) newHistory.shift();
                setHistory(newHistory);
                setIndex(newHistory.length - 1);
            };

            const undo = () => index > 0 && setIndex(index - 1);
            const redo = () => index < history.length - 1 && setIndex(index + 1);

            return [history[index], setState, undo, redo, index > 0, index < history.length - 1];
        }

        // --- CONSTANTS ---
        const CONFIG = {
            gridSize: 40, nodeRadius: 8, hitRadius: 15,
            colors: { selection: '#2563eb', path: '#10b981', walkable: '#64748b', destination: '#ef4444', kiosk: '#f59e0b', bathroom: '#8b5cf6', elevator: '#06b6d4', stairs: '#ec4899' }
        };
        const generateId = () => Math.random().toString(36).substr(2, 9);

        // --- SERVICES ---
        async function uploadToImgBB(base64Image) {
            const formData = new FormData();
            const cleanBase64 = base64Image.split(',')[1];
            formData.append('image', cleanBase64);
            const response = await fetch(`https://api.imgbb.com/1/upload?key=${window.IMGBB_API_KEY}`, { method: 'POST', body: formData });
            const result = await response.json();
            if (result.success) return result.data.url;
            throw new Error(result.error ? result.error.message : 'Upload failed');
        }

        async function deployToKiosk(mapData, mapId, userId) {
            if (!window.db) throw new Error("Database not connected.");
            const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error("Database connection timed out.")), 15000));
            
            // 1. Save Map
            const saveMapPromise = window.setDoc(window.doc(window.db, "users", userId, "maps", mapId), { ...mapData, ownerId: userId, updatedAt: window.serverTimestamp() });
            await Promise.race([saveMapPromise, timeoutPromise]);
            
            // 2. Generate Code
            const code = Math.random().toString(36).substring(2, 8).toUpperCase();
            const saveCodePromise = window.setDoc(window.doc(window.db, "pairing_codes", code), { code, mapId, status: "waiting", createdAt: window.serverTimestamp(), ownerId: userId });
            await Promise.race([saveCodePromise, timeoutPromise]);
            
            return code;
        }
        
        async function syncUpdates(mapData, mapId, userId) {
            if (!window.db) throw new Error("Database not connected.");
            const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error("Database connection timed out.")), 15000));
            const saveMapPromise = window.setDoc(window.doc(window.db, "users", userId, "maps", mapId), { ...mapData, ownerId: userId, updatedAt: window.serverTimestamp() });
            await Promise.race([saveMapPromise, timeoutPromise]);
        }

        // --- COMPONENTS ---
        const Icon = ({ name, className = '' }) => <i className={`fas fa-${name} ${className}`}></i>;

        const ToolButton = ({ active, icon, label, onClick }) => (
            <button onClick={onClick} className={`w-10 h-10 rounded-lg flex items-center justify-center transition-all ${active ? 'bg-brand-600 text-white shadow-inner' : 'bg-white text-slate-600 hover:bg-slate-50 border border-slate-200'}`} title={label}>
                <Icon name={icon} />
            </button>
        );

        const NavButton = ({ active, icon, label, onClick }) => (
            <button onClick={onClick} className={`w-full p-3 flex flex-col items-center justify-center transition-colors ${active ? 'text-brand-600 bg-brand-50 border-r-2 border-brand-600' : 'text-slate-500 hover:bg-slate-50'}`}>
                <Icon name={icon} className="text-xl mb-1" />
                <span className="text-[10px] font-medium">{label}</span>
            </button>
        );

        const DeployModal = ({ isOpen, onClose, code, isLoading, progress }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-slate-900/60 z-[100] flex items-center justify-center backdrop-blur-sm animate-fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl p-8 w-96 text-center">
                        <div className={`w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4 text-2xl ${isLoading ? 'bg-blue-100 text-blue-600' : 'bg-green-100 text-green-600'}`}>
                            <Icon name={isLoading ? "spinner" : "check"} className={isLoading ? "fa-spin" : ""} />
                        </div>
                        <h2 className="text-xl font-bold text-slate-800 mb-2">{isLoading ? 'Deploying...' : 'Connect Kiosk'}</h2>
                        {isLoading ? (
                            <p className="text-slate-500 text-sm">{progress}</p>
                        ) : (
                            <>
                                <p className="text-slate-500 text-sm mb-6">Enter this code on your Kiosk Player app.</p>
                                <div className="bg-slate-100 border-2 border-dashed border-slate-300 rounded-lg p-4 mb-6">
                                    <span className="text-4xl font-mono font-bold tracking-widest text-slate-800">{code}</span>
                                </div>
                                <button onClick={onClose} className="w-full bg-slate-100 hover:bg-slate-200 text-slate-700 font-bold py-3 rounded-lg transition">Close</button>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        const MapLibrary = ({ onEditMap, userId }) => {
            const [maps, setMaps] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const fetchMaps = async () => {
                    if (!userId) return;
                    setLoading(true);
                    try {
                        const mapsRef = window.collection(window.db, "users", userId, "maps");
                        const q = window.query(mapsRef, window.where("ownerId", "==", userId));
                        const snapshot = await window.getDocs(q);
                        const mapList = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setMaps(mapList);
                    } catch (e) { console.error("Map Fetch Error:", e); }
                    setLoading(false);
                };
                fetchMaps();
            }, [userId]);

            const deleteMap = async (id) => {
                if(!confirm("Delete this map?")) return;
                try {
                    await window.deleteDoc(window.doc(window.db, "users", userId, "maps", id));
                    setMaps(maps.filter(m => m.id !== id));
                } catch(e) { alert("Delete failed: " + e.message); }
            };

            if (loading) return <div className="p-8 text-center text-slate-500"><Icon name="spinner" className="fa-spin text-2xl" /> Loading Maps...</div>;

            return (
                <div className="p-8 h-full overflow-y-auto bg-slate-50">
                    <h1 className="text-2xl font-bold text-slate-800 mb-6">Map Library</h1>
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        {maps.map(map => (
                            <div key={map.id} className="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden hover:shadow-md transition-shadow group">
                                <div className="h-40 bg-slate-100 relative overflow-hidden">
                                    {map.metadata?.mapImage ? (
                                        <img src={map.metadata.mapImage} className="w-full h-full object-cover" onError={(e) => e.target.src = "https://placehold.co/400x200?text=No+Image"}/>
                                    ) : (
                                        <div className="w-full h-full flex items-center justify-center text-slate-300"><Icon name="image" className="text-3xl" /></div>
                                    )}
                                    <div className="absolute inset-0 bg-black/50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                                        <button onClick={() => onEditMap(map)} className="bg-white text-slate-900 px-4 py-2 rounded-full font-bold text-sm hover:bg-brand-50">Edit Map</button>
                                    </div>
                                </div>
                                <div className="p-4">
                                    <h3 className="font-bold text-slate-800 truncate">{map.metadata?.name || "Untitled Map"}</h3>
                                    <div className="flex justify-between items-center mt-2 text-xs text-slate-500">
                                        <span>{map.nodes?.length || 0} Nodes</span>
                                        <span>{map.updatedAt ? new Date(map.updatedAt.seconds * 1000).toLocaleDateString() : 'Draft'}</span>
                                    </div>
                                    <div className="mt-4 pt-3 border-t border-slate-100 flex justify-end">
                                        <button onClick={() => deleteMap(map.id)} className="text-red-500 hover:text-red-700 text-xs flex items-center gap-1"><Icon name="trash" /> Delete</button>
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const DeviceManager = ({ userId }) => {
            const [devices, setDevices] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const fetchDevices = async () => {
                    if (!userId) return;
                    setLoading(true);
                    try {
                        const q = window.query(window.collection(window.db, "pairing_codes"), window.where("ownerId", "==", userId));
                        const snapshot = await window.getDocs(q);
                        setDevices(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))); 
                    } catch (e) { console.error(e); }
                    setLoading(false);
                };
                fetchDevices();
            }, [userId]);

            const deleteDevice = async (id) => {
                if(!confirm("Revoke?")) return;
                try {
                    await window.deleteDoc(window.doc(window.db, "pairing_codes", id));
                    setDevices(devices.filter(d => d.id !== id));
                } catch(e) { alert("Error: " + e.message); }
            };

            if (loading) return <div className="p-8 text-center text-slate-500"><Icon name="spinner" className="fa-spin text-2xl" /> Loading...</div>;

            return (
                <div className="p-8 h-full overflow-y-auto bg-slate-50">
                    <h1 className="text-2xl font-bold text-slate-800 mb-6">Device Management</h1>
                    <div className="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
                        <table className="w-full text-left text-sm">
                            <thead className="bg-slate-50 border-b border-slate-200 text-slate-500 uppercase text-xs">
                                <tr><th className="p-4">Code</th><th className="p-4">Map ID</th><th className="p-4">Status</th><th className="p-4 text-right">Actions</th></tr>
                            </thead>
                            <tbody className="divide-y divide-slate-100">
                                {devices.map(device => (
                                    <tr key={device.id} className="hover:bg-slate-50">
                                        <td className="p-4 font-mono font-bold text-brand-600">{device.code}</td>
                                        <td className="p-4 text-slate-600">{device.mapId}</td>
                                        <td className="p-4"><span className={`px-2 py-1 rounded-full text-xs font-medium ${device.status === 'active' ? 'bg-green-100 text-green-700' : 'bg-yellow-100 text-yellow-700'}`}>{device.status}</span></td>
                                        <td className="p-4 text-right"><button onClick={() => deleteDevice(device.id)} className="text-red-500 hover:bg-red-50 px-3 py-1.5 rounded transition">Revoke</button></td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        const Editor = ({ initialData }) => {
            const userId = window.auth?.currentUser?.uid;
            
            // --- STATE WITH HISTORY ---
            const [state, setState, undo, redo, canUndo, canRedo] = useHistory({
                nodes: initialData?.nodes || [],
                edges: initialData?.edges || []
            });
            const { nodes, edges } = state;

            const [mapId, setMapId] = useState(initialData?.id || `map_${generateId()}`);
            const [mapName, setMapName] = useState(initialData?.metadata?.name || "Untitled Project");
            const [mapImage, setMapImage] = useState(initialData?.metadata?.mapImage || null);
            const [lastSaved, setLastSaved] = useState(initialData?.updatedAt ? new Date(initialData.updatedAt.seconds * 1000) : null);
            const [isCloudMap, setIsCloudMap] = useState(!!initialData?.id);
            const [mode, setMode] = useState('editor'); // 'editor' | 'preview'

            // Deployment State
            const [showDeployModal, setShowDeployModal] = useState(false);
            const [deployCode, setDeployCode] = useState(null);
            const [isDeploying, setIsDeploying] = useState(false);
            const [isSyncing, setIsSyncing] = useState(false);
            const [uploadProgress, setUploadProgress] = useState('');

            // Canvas State
            const [toolMode, setToolMode] = useState('select');
            const [selectedId, setSelectedId] = useState(null);
            const [view, setView] = useState({ scale: 1, x: 0, y: 0 });
            const [previewPath, setPreviewPath] = useState(null);
            
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const imgRef = useRef(null);
            const dragRef = useRef(null);
            const tempEdgeRef = useRef(null);

            useEffect(() => {
                if (mapImage) {
                    const img = new Image();
                    img.src = mapImage;
                    img.onload = () => { imgRef.current = img; };
                }
            }, [mapImage]);

            // --- DEPLOYMENT ---
            const prepareMapData = async (isNewDeployment) => {
                let finalUrl = mapImage;
                if (isNewDeployment || mapImage?.startsWith('data:')) {
                    setUploadProgress('Uploading Image...');
                    finalUrl = await uploadToImgBB(mapImage);
                    setMapImage(finalUrl); 
                }
                return {
                    metadata: { version: "3.0", generated: new Date().toISOString(), mapImage: finalUrl, name: mapName },
                    nodes, edges
                };
            };

            const handleNewDeploy = async () => {
                if(!mapImage) { alert("Please upload a map first."); return; }
                setIsDeploying(true); setShowDeployModal(true); setDeployCode(null); setUploadProgress('Initializing...');
                try {
                    const data = await prepareMapData(true); 
                    setUploadProgress('Generating Code...');
                    const code = await deployToKiosk(data, mapId, userId);
                    setDeployCode(code);
                    setIsCloudMap(true);
                    setLastSaved(new Date());
                } catch (e) { alert("Deployment Failed: " + e.message); setShowDeployModal(false); }
                setIsDeploying(false);
            };

            const handleSyncUpdate = async () => {
                if(!mapImage) return;
                setIsSyncing(true);
                try {
                    const data = await prepareMapData(false); 
                    await syncUpdates(data, mapId, userId);
                    setLastSaved(new Date());
                    alert("Synced!");
                } catch (e) { alert("Sync failed: " + e.message); }
                setIsSyncing(false);
            };

            const handleExport = () => {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify({metadata: {name: mapName, mapImage: mapImage?.startsWith('data') ? null : mapImage}, nodes, edges}));
                const dl = document.createElement('a'); dl.setAttribute("href", dataStr); dl.setAttribute("download", `${mapName}.json`); dl.click();
            };

            const handleImport = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);
                        setMapName(data.metadata.name || "Imported Map");
                        setState({ nodes: data.nodes, edges: data.edges });
                        if (data.metadata.mapImage) setMapImage(data.metadata.mapImage);
                        else alert("Map Data Loaded. Please re-upload the map image.");
                    } catch(err) { alert("Invalid JSON"); }
                };
                reader.readAsText(file);
            };

            // --- CANVAS LOGIC ---
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const render = () => {
                    canvas.width = containerRef.current?.clientWidth || 800; canvas.height = containerRef.current?.clientHeight || 600;
                    ctx.clearRect(0,0,canvas.width,canvas.height); ctx.save();
                    ctx.translate(view.x, view.y); ctx.scale(view.scale, view.scale);
                    if (imgRef.current) {
                        ctx.drawImage(imgRef.current, 0, 0);
                        if (mode === 'editor') {
                            ctx.beginPath(); ctx.strokeStyle = 'rgba(0,0,0,0.05)'; ctx.lineWidth=1/view.scale;
                            for(let x=0; x<=imgRef.current.width; x+=CONFIG.gridSize) { ctx.moveTo(x,0); ctx.lineTo(x,imgRef.current.height); }
                            for(let y=0; y<=imgRef.current.height; y+=CONFIG.gridSize) { ctx.moveTo(0,y); ctx.lineTo(imgRef.current.width,y); }
                            ctx.stroke();
                        }
                    }
                    edges.forEach(e => {
                        const n1 = nodes.find(n=>n.id===e.from), n2 = nodes.find(n=>n.id===e.to);
                        if(n1 && n2) {
                            ctx.beginPath(); ctx.moveTo(n1.x, n1.y); ctx.lineTo(n2.x, n2.y);
                            ctx.strokeStyle = selectedId === e.id ? CONFIG.colors.selection : '#94a3b8';
                            ctx.lineWidth = (selectedId === e.id ? 4 : 2) / view.scale;
                            if (mode === 'preview') ctx.strokeStyle = 'rgba(148, 163, 184, 0.4)';
                            ctx.stroke();
                        }
                    });
                    if (tempEdgeRef.current) {
                        const n1 = nodes.find(n=>n.id===tempEdgeRef.current.start);
                        if(n1) { ctx.beginPath(); ctx.moveTo(n1.x, n1.y); ctx.lineTo(tempEdgeRef.current.curr.x, tempEdgeRef.current.curr.y); ctx.strokeStyle = CONFIG.colors.selection; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]); }
                    }
                    if (mode === 'preview' && previewPath) {
                        ctx.beginPath(); ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 6/view.scale; ctx.lineCap='round'; ctx.lineJoin='round';
                        ctx.moveTo(previewPath[0].x, previewPath[0].y);
                        for(let i=1; i<previewPath.length; i++) ctx.lineTo(previewPath[i].x, previewPath[i].y);
                        ctx.stroke();
                    }
                    nodes.forEach(n => {
                        if (mode === 'preview' && n.type === 'walkable') return;
                        const isSel = selectedId === n.id;
                        ctx.beginPath(); ctx.arc(n.x, n.y, (isSel ? 12 : 8)/view.scale, 0, Math.PI*2);
                        ctx.fillStyle = CONFIG.colors[n.type] || CONFIG.colors.walkable; ctx.fill();
                        if(isSel) { ctx.strokeStyle = '#fff'; ctx.lineWidth=2/view.scale; ctx.stroke(); }
                        if(n.name) { ctx.font=`600 ${12/view.scale}px Inter`; ctx.fillStyle='#1e293b'; ctx.textAlign='center'; ctx.fillText(n.name, n.x, n.y - 15/view.scale); }
                    });
                    ctx.restore();
                    requestAnimationFrame(render);
                };
                render();
            }, [nodes, edges, view, selectedId, mapImage, mode, previewPath]);

            // Handlers (Simplified)
            const handleMouseDown = (e) => {
                const rect = containerRef.current.getBoundingClientRect();
                const mx = e.clientX - rect.left, my = e.clientY - rect.top;
                const wPos = { x: (mx - view.x)/view.scale, y: (my - view.y)/view.scale };
                const hitNode = nodes.find(n => Math.hypot(n.x - wPos.x, n.y - wPos.y) < 15/view.scale);

                if (toolMode === 'pan' || e.button === 1) { dragRef.current = { type: 'pan', sx: mx, sy: my, vStart: {...view} }; return; }
                
                if (mode === 'preview') {
                    if (hitNode && hitNode.type !== 'walkable') {
                        // Dijkstra Mock
                        const kiosk = nodes.find(n => n.type === 'kiosk');
                        if (kiosk) setPreviewPath([kiosk, hitNode]); // Straight line for demo
                    }
                    return;
                }

                if (toolMode === 'select') { if (hitNode) { setSelectedId(hitNode.id); dragRef.current = { type: 'move', id: hitNode.id }; } else setSelectedId(null); }
                else if (toolMode === 'node') { 
                    if (hitNode) setSelectedId(hitNode.id);
                    else { const id = generateId(); setState({ nodes: [...nodes, { id, x: wPos.x, y: wPos.y, type: 'walkable', name: '' }], edges }); setSelectedId(id); } 
                }
                else if (toolMode === 'edge' && hitNode) tempEdgeRef.current = { start: hitNode.id, curr: wPos };
            };

            const handleMouseMove = (e) => {
                const rect = containerRef.current.getBoundingClientRect();
                const mx = e.clientX - rect.left, my = e.clientY - rect.top;
                const wPos = { x: (mx - view.x)/view.scale, y: (my - view.y)/view.scale };

                if (dragRef.current?.type === 'pan') { setView({ ...view, x: dragRef.current.vStart.x + (mx - dragRef.current.sx), y: dragRef.current.vStart.y + (my - dragRef.current.sy) }); }
                else if (dragRef.current?.type === 'move' && mode === 'editor') { 
                    // Update temp nodes state without triggering history every frame
                    // For simplicity in this demo, updating state directly. In prod, use refs or debounce.
                    const updatedNodes = nodes.map(n => n.id === dragRef.current.id ? { ...n, x: wPos.x, y: wPos.y } : n);
                    // This bypasses history for performance, should commit on MouseUp
                    setState({nodes: updatedNodes, edges}); 
                }
                else if (tempEdgeRef.current) tempEdgeRef.current.curr = wPos;
            };

            const handleMouseUp = (e) => {
                if (tempEdgeRef.current) {
                    const rect = containerRef.current.getBoundingClientRect();
                    const wPos = { x: (e.clientX - rect.left - view.x)/view.scale, y: (e.clientY - rect.top - view.y)/view.scale };
                    const hitNode = nodes.find(n => Math.hypot(n.x - wPos.x, n.y - wPos.y) < 15/view.scale);
                    if (hitNode && hitNode.id !== tempEdgeRef.current.start) {
                        setState({ nodes, edges: [...edges, { id: generateId(), from: tempEdgeRef.current.start, to: hitNode.id, weight: 1, accessible: true }] });
                    }
                    tempEdgeRef.current = null;
                }
                dragRef.current = null;
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if(file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const img = new Image(); img.src = evt.target.result;
                        img.onload = () => { imgRef.current = img; setMapImage(evt.target.result); setView({ scale: Math.min((containerRef.current.clientWidth-40)/img.width, (containerRef.current.clientHeight-40)/img.height), x: 20, y: 20 }); }
                    };
                    reader.readAsDataURL(file);
                }
            };

            const selectedElement = nodes.find(n => n.id === selectedId) || edges.find(e => e.id === selectedId);

            return (
                <div className="flex flex-col h-full bg-white font-sans text-slate-800">
                    {/* HEADER */}
                    <div className="h-16 border-b border-slate-200 flex items-center justify-between px-6 shrink-0 bg-white z-20">
                        <div className="flex items-center gap-4">
                            <div className="w-10 h-10 bg-brand-600 rounded-lg flex items-center justify-center text-white font-bold text-xl">W</div>
                            <div>
                                <input value={mapName} onChange={(e) => setMapName(e.target.value)} className="font-bold text-lg text-slate-800 bg-transparent border border-transparent hover:border-slate-300 px-2 -ml-2 rounded transition focus:border-brand-500 outline-none block w-64" />
                                <div className="flex items-center text-[11px] font-medium mt-0.5">
                                    <span className="text-green-600 flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-green-500"></span> Online</span>
                                    <span className="text-slate-300 mx-2">‚Ä¢</span>
                                    <span className="text-slate-400">{lastSaved ? `Saved ${lastSaved.toLocaleTimeString()}` : "Unsaved"}</span>
                                </div>
                            </div>
                        </div>

                        {/* CENTER: UNDO/REDO */}
                        <div className="flex items-center gap-2">
                            <button onClick={undo} disabled={!canUndo} className="w-9 h-9 rounded-full hover:bg-slate-100 flex items-center justify-center text-slate-500 disabled:opacity-30 disabled:hover:bg-transparent transition-colors"><Icon name="undo" /></button>
                            <button onClick={redo} disabled={!canRedo} className="w-9 h-9 rounded-full hover:bg-slate-100 flex items-center justify-center text-slate-500 disabled:opacity-30 disabled:hover:bg-transparent transition-colors"><Icon name="redo" /></button>
                        </div>

                        {/* RIGHT: ACTIONS */}
                        <div className="flex items-center gap-3">
                            <div className="flex bg-slate-100 p-1 rounded-lg border border-slate-200">
                                <button onClick={() => setMode('editor')} className={`px-4 py-1.5 text-xs font-semibold rounded-md transition-all ${mode === 'editor' ? 'bg-white shadow text-slate-800' : 'text-slate-500 hover:text-slate-700'}`}>Editor</button>
                                <button onClick={() => setMode('preview')} className={`px-4 py-1.5 text-xs font-semibold rounded-md transition-all ${mode === 'preview' ? 'bg-white shadow text-slate-800' : 'text-slate-500 hover:text-slate-700'}`}>Preview</button>
                            </div>
                            
                            <div className="h-8 w-px bg-slate-200 mx-2"></div>

                            <button onClick={handleExport} className="px-3 py-2 text-xs font-medium border border-slate-300 rounded-lg hover:bg-slate-50 flex items-center gap-2 text-slate-600"><Icon name="download" /> Export</button>
                            <label className="px-3 py-2 text-xs font-medium bg-slate-800 hover:bg-slate-900 text-white rounded-lg cursor-pointer flex items-center gap-2 transition-colors">
                                <Icon name="folder-open" /> Import
                                <input type="file" onChange={handleImport} className="hidden" accept=".json" />
                            </label>

                            <div className="h-8 w-px bg-slate-200 mx-2"></div>

                            {isCloudMap ? (
                                <button onClick={handleSyncUpdate} disabled={isSyncing} className="px-4 py-2 text-xs font-bold bg-blue-100 text-blue-700 hover:bg-blue-200 rounded-lg flex items-center gap-2 transition-colors">
                                    <Icon name={isSyncing ? "spinner" : "sync"} className={isSyncing ? "fa-spin" : ""} /> Sync Updates
                                </button>
                            ) : (
                                <button onClick={handleNewDeploy} className="px-4 py-2 text-xs font-bold bg-brand-600 hover:bg-brand-700 text-white rounded-lg shadow-sm flex items-center gap-2 transition-all">
                                    <Icon name="cloud-upload-alt" /> Deploy to Kiosk
                                </button>
                            )}
                        </div>
                    </div>

                    <div className="flex-1 flex overflow-hidden">
                        {/* LEFT TOOLBAR */}
                        <div className={`w-16 border-r border-slate-200 flex flex-col items-center py-4 gap-4 bg-white z-10 transition-opacity ${mode === 'preview' ? 'opacity-50 pointer-events-none' : ''}`}>
                            <ToolButton icon="mouse-pointer" label="Select" active={toolMode==='select'} onClick={()=>setToolMode('select')} />
                            <ToolButton icon="circle-dot" label="Node" active={toolMode==='node'} onClick={()=>setToolMode('node')} />
                            <ToolButton icon="draw-polygon" label="Edge" active={toolMode==='edge'} onClick={()=>setToolMode('edge')} />
                            <ToolButton icon="hand" label="Pan" active={toolMode==='pan'} onClick={()=>setToolMode('pan')} />
                            <div className="h-px w-8 bg-slate-200 my-2"></div>
                            <label className="w-10 h-10 rounded-xl flex items-center justify-center bg-slate-50 text-slate-600 hover:bg-brand-50 hover:text-brand-600 border border-slate-200 cursor-pointer transition-colors" title="Upload Map">
                                <Icon name="image" /> <input type="file" onChange={handleImageUpload} className="hidden" accept="image/*" />
                            </label>
                        </div>

                        {/* CANVAS */}
                        <div className="flex-1 relative bg-slate-100 overflow-hidden cursor-pan" ref={containerRef} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onWheel={(e)=>{setView({...view, scale: Math.max(0.1, view.scale*(1-e.deltaY*0.001))})}}>
                            <canvas ref={canvasRef} className="block" />
                            {mode === 'preview' && (
                                <div className="absolute top-4 left-1/2 -translate-x-1/2 bg-slate-900/90 text-white px-4 py-2 rounded-full shadow-lg text-xs font-medium backdrop-blur-sm animate-fade-in pointer-events-none flex items-center gap-2">
                                    <span className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></span> Preview Mode: Click any node to test pathfinding
                                </div>
                            )}
                            {!mapImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="bg-white/80 p-8 rounded-2xl shadow-xl text-center backdrop-blur border border-white/50"><div className="text-5xl mb-4">üó∫Ô∏è</div><h3 className="font-bold text-slate-800 text-lg">No Map Loaded</h3><p className="text-slate-500 text-sm">Upload a floor plan image to begin</p></div></div>}
                        </div>

                        {/* RIGHT PROPERTIES */}
                        {mode === 'editor' ? (
                            <div className="w-80 bg-white border-l border-slate-200 flex flex-col shadow-xl z-10">
                                <div className="h-12 border-b border-slate-100 flex items-center justify-between px-5">
                                    <span className="text-xs font-bold text-slate-500 uppercase tracking-wider">Properties</span>
                                    {selectedElement && <span className="text-[10px] bg-slate-100 text-slate-500 px-2 py-0.5 rounded font-mono">{selectedId.substr(-6)}</span>}
                                </div>
                                <div className="p-5 flex-1 overflow-y-auto">
                                    {selectedElement ? (
                                        <div className="space-y-5 animate-fade-in">
                                            {selectedElement.hasOwnProperty('name') ? (
                                                <>
                                                    <div><label className="block text-xs font-semibold text-slate-700 mb-1.5">Label</label><input type="text" value={selectedElement.name} onChange={e => {
                                                        const newVal = e.target.value;
                                                        setState({ nodes: nodes.map(n => n.id === selectedId ? {...n, name: newVal} : n), edges });
                                                    }} className="w-full border border-slate-300 rounded-lg p-2.5 text-sm focus:ring-2 focus:ring-brand-500 focus:border-brand-500 outline-none transition-shadow" placeholder="e.g. Main Entrance" /></div>
                                                    <div><label className="block text-xs font-semibold text-slate-700 mb-1.5">Type</label><select value={selectedElement.type} onChange={e => {
                                                        const newVal = e.target.value;
                                                        setState({ nodes: nodes.map(n => n.id === selectedId ? {...n, type: newVal} : n), edges });
                                                    }} className="w-full border border-slate-300 rounded-lg p-2.5 text-sm bg-white focus:ring-2 focus:ring-brand-500 outline-none">{Object.keys(CONFIG.colors).map(t => <option key={t} value={t}>{t.charAt(0).toUpperCase() + t.slice(1)}</option>)}</select></div>
                                                    <div className="pt-4 border-t border-slate-100">
                                                        <button onClick={() => { 
                                                            setState({ nodes: nodes.filter(n => n.id !== selectedId), edges: edges.filter(e => e.from !== selectedId && e.to !== selectedId) });
                                                            setSelectedId(null); 
                                                        }} className="w-full bg-white border border-red-200 text-red-600 py-2.5 rounded-lg text-xs font-bold hover:bg-red-50 transition-colors flex items-center justify-center gap-2"><Icon name="trash" /> Delete Node</button>
                                                    </div>
                                                </>
                                            ) : (
                                                <>
                                                    <div><label className="block text-xs font-semibold text-slate-700 mb-1.5">Weight (Cost)</label><input type="number" value={selectedElement.weight} onChange={e => {
                                                        const newVal = parseInt(e.target.value) || 1;
                                                        setState({ nodes, edges: edges.map(ed => ed.id === selectedId ? {...ed, weight: newVal} : ed) });
                                                    }} className="w-full border border-slate-300 rounded-lg p-2.5 text-sm outline-none focus:ring-2 focus:ring-brand-500" /></div>
                                                    <div className="pt-4 border-t border-slate-100">
                                                        <button onClick={() => { 
                                                            setState({ nodes, edges: edges.filter(e => e.id !== selectedId) });
                                                            setSelectedId(null); 
                                                        }} className="w-full bg-white border border-red-200 text-red-600 py-2.5 rounded-lg text-xs font-bold hover:bg-red-50 transition-colors flex items-center justify-center gap-2"><Icon name="trash" /> Delete Edge</button>
                                                    </div>
                                                </>
                                            )}
                                        </div>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center h-48 text-slate-400 text-center">
                                            <Icon name="mouse-pointer" className="text-3xl mb-3 opacity-20" />
                                            <p className="text-sm">Select an element on the<br/>canvas to edit properties</p>
                                        </div>
                                    )}
                                </div>
                                <div className="p-4 bg-slate-50 border-t border-slate-200 text-xs font-medium text-slate-500 flex justify-between">
                                    <span>{nodes.length} Nodes</span>
                                    <span>{edges.length} Edges</span>
                                </div>
                            </div>
                        ) : (
                            <div className="w-80 bg-slate-50 border-l border-slate-200 flex items-center justify-center text-slate-400 text-sm">
                                Preview Mode Active
                            </div>
                        )}
                    </div>
                    <DeployModal isOpen={showDeployModal} onClose={() => setShowDeployModal(false)} code={deployCode} isLoading={isDeploying} progress={uploadProgress} />
                </div>
            );
        };

        const App = () => {
            const { user, loading } = useAuthStatus();
            const [view, setView] = useState('studio');
            const [currentMapData, setCurrentMapData] = useState(null);

            const handleEditMap = (mapData) => { setCurrentMapData(mapData); setView('studio'); };
            
            if (loading) {
                if (document.getElementById('loading-fallback')) document.getElementById('loading-fallback').style.display = 'none';
                return <div className="h-full flex items-center justify-center text-slate-500"><Icon name="spinner" className="fa-spin text-4xl" /></div>;
            }

            if (!user) {
                if (document.getElementById('loading-fallback')) document.getElementById('loading-fallback').style.display = 'none';
                return (
                    <div className="h-full flex items-center justify-center bg-slate-100">
                        <div className="bg-white p-10 rounded-2xl shadow-xl text-center max-w-sm">
                            <div className="w-16 h-16 bg-red-100 text-red-600 rounded-full flex items-center justify-center mx-auto mb-4 text-3xl"><Icon name="lock" /></div>
                            <h2 className="text-2xl font-bold mb-2">Login Required</h2>
                            <p className="text-slate-500 mb-6">Please log in via the main landing page.</p>
                            <button onClick={() => { try { window.location.href = 'index.html'; } catch (e) {} }} className="w-full py-3 bg-brand-600 text-white rounded-lg font-bold hover:bg-brand-700">Go to Login</button>
                        </div>
                    </div>
                );
            }
            
            return (
                <div className="flex h-full font-sans text-slate-800">
                    <div className="w-20 bg-slate-900 flex flex-col items-center py-6 gap-6 text-slate-400 z-50">
                        <div className="w-10 h-10 bg-gradient-to-br from-brand-500 to-brand-700 rounded-lg flex items-center justify-center text-white font-bold text-xl shadow-lg mb-4 cursor-pointer" onClick={() => window.location.href='/'}>W</div>
                        <NavButton active={view === 'studio'} icon="pen-nib" label="Studio" onClick={() => { setView('studio'); setCurrentMapData(null); }} /> 
                        <NavButton active={view === 'maps'} icon="map" label="Maps" onClick={() => setView('maps')} />
                        <NavButton active={view === 'devices'} icon="tablet-alt" label="Devices" onClick={() => setView('devices')} />
                    </div>
                    <div className="flex-1 bg-slate-100 overflow-hidden relative">
                        {view === 'studio' && <Editor initialData={currentMapData} key={currentMapData ? currentMapData.id : 'new'} />}
                        {view === 'maps' && <MapLibrary onEditMap={handleEditMap} userId={user.uid} />}
                        {view === 'devices' && <DeviceManager userId={user.uid} />}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
