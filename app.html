<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wayfinder Studio Enterprise</title>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    colors: { brand: { 500: '#3b82f6', 600: '#2563eb', 700: '#1d4ed8' } }
                }
            }
        }
    </script>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "firebase/app": "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js",
                "firebase/firestore": "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js",
                "firebase/auth": "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js"
            }
        }
    </script>

    <script type="module">
        import { initializeApp } from "firebase/app";
        import { getFirestore, doc, setDoc, getDoc, getDocs, deleteDoc, collection, query, where, serverTimestamp } from "firebase/firestore";
        import { getAuth, onAuthStateChanged } from "firebase/auth";

        // --- YOUR CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyDWJ5qVnsA3rWvfkc0-_cIyfwLHEZNMuxE",
            authDomain: "wayfinder-app-a2565.firebaseapp.com",
            projectId: "wayfinder-app-a2565",
            storageBucket: "wayfinder-app-a2565.firebasestorage.app",
            messagingSenderId: "770872636942",
            appId: "1:770872636942:web:f342a0d96de313a19a6e5f",
            measurementId: "G-W7BXXBPLGX"
        };

        try {
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            const auth = getAuth(app);

            window.db = db;
            window.auth = auth;
            window.setDoc = setDoc;
            window.getDoc = getDoc;
            window.getDocs = getDocs;
            window.deleteDoc = deleteDoc;
            window.doc = doc;
            window.collection = collection;
            window.query = query;
            window.where = where;
            window.serverTimestamp = serverTimestamp;
            window.IMGBB_API_KEY = "d3c464ab1b35134225f0bf7787c09d16";
            
            onAuthStateChanged(auth, (user) => {
                window.dispatchEvent(new CustomEvent('firebase-auth-initialized', { detail: user }));
            });

        } catch (err) {
            console.error("Firebase Init Error", err);
        }
    </script>

    <style>
        body { background-color: #f1f5f9; overflow: hidden; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .cursor-pan { cursor: grab; }
        .cursor-panning { cursor: grabbing; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.2s ease-out forwards; }
        .path-line { stroke-dasharray: 10; animation: dash 1s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -20; } }
        .nav-item.active { background-color: #e2e8f0; color: #2563eb; }
    </style>
</head>
<body>
    <div id="root" class="h-screen w-screen flex flex-col">
        <div id="loading-fallback" class="h-full flex items-center justify-center text-slate-400">
            <i class="fas fa-spinner fa-spin text-4xl"></i>
            <span class="ml-3">Loading Studio...</span>
        </div>
    </div>

    <script type="text/babel" data-presets="react,typescript">
        const { useState, useRef, useEffect, useCallback, Component } = React;

        // --- 0. AUTH HOOK (FIXED: Added missing function) ---
        function useAuthStatus() {
            const [user, setUser] = useState(null);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const handleAuthInit = (e) => { setUser(e.detail); setLoading(false); };
                window.addEventListener('firebase-auth-initialized', handleAuthInit);
                
                // Fallback check if window.auth is already ready
                if (window.auth) {
                    const unsubscribe = window.auth.onAuthStateChanged((u) => { 
                        setUser(u); 
                        setLoading(false); 
                    });
                    return () => {
                        window.removeEventListener('firebase-auth-initialized', handleAuthInit);
                        unsubscribe();
                    };
                }
                
                return () => window.removeEventListener('firebase-auth-initialized', handleAuthInit);
            }, []);
            return { user, loading };
        }

        // --- 1. CONFIGURATION & SAFETY ---
        const ENV = {
            FIREBASE: {
                apiKey: "AIzaSyDWJ5qVnsA3rWvfkc0-_cIyfwLHEZNMuxE",
                authDomain: "wayfinder-app-a2565.firebaseapp.com",
                projectId: "wayfinder-app-a2565",
                storageBucket: "wayfinder-app-a2565.firebasestorage.app",
                messagingSenderId: "770872636942",
                appId: "1:770872636942:web:f342a0d96de313a19a6e5f"
            },
            IMGBB_KEY: "d3c464ab1b35134225f0bf7787c09d16"
        };

        const CONFIG = {
            gridSize: 40, 
            nodeRadius: 8, 
            hitRadius: 15,
            // Default colors
            colors: { selection: '#2563eb', path: '#10b981', walkable: '#64748b', destination: '#ef4444', kiosk: '#f59e0b', bathroom: '#8b5cf6', elevator: '#06b6d4', stairs: '#ec4899', custom: '#888888' }
        };

        const UTILS = {
            generateId: () => Math.random().toString(36).substr(2, 9),
            sanitize: (str) => str ? str.replace(/[^\w\s\-\.\:\/]/gi, '') : '' 
        };

        // --- 2. ERROR BOUNDARY ---
        class ErrorBoundary extends Component {
            constructor(props) { super(props); this.state = { hasError: false }; }
            static getDerivedStateFromError(error) { return { hasError: true }; }
            componentDidCatch(error, errorInfo) { console.error("UI Crash:", error, errorInfo); }
            render() {
                if (this.state.hasError) return <div className="p-10 text-red-600">Something went wrong. Refresh to reset.</div>;
                return this.props.children; 
            }
        }

        // --- 3. SERVICES (Firebase & ImgBB) ---
        async function uploadToImgBB(base64Image) {
            const formData = new FormData();
            formData.append('image', base64Image.split(',')[1]);
            const response = await fetch(`https://api.imgbb.com/1/upload?key=${ENV.IMGBB_KEY}`, { method: 'POST', body: formData });
            const result = await response.json();
            if (result.success) return result.data.url;
            throw new Error(result.error ? result.error.message : 'Upload failed');
        }

        async function deployToKiosk(mapData, mapId, userId) {
            if (!window.db) throw new Error("Database not connected.");
            await window.setDoc(window.doc(window.db, "users", userId, "maps", mapId), { ...mapData, ownerId: userId, updatedAt: window.serverTimestamp() });
            const code = Math.random().toString(36).substring(2, 8).toUpperCase();
            await window.setDoc(window.doc(window.db, "pairing_codes", code), { code, mapId, status: "waiting", createdAt: window.serverTimestamp(), ownerId: userId });
            return code;
        }

        // --- 4. COMPONENTS ---
        const Icon = ({ name, className = '' }) => <i className={`fas fa-${name} ${className}`} aria-hidden="true"></i>;

        const Editor = ({ initialData }) => {
            const userId = window.auth?.currentUser?.uid;
            const [mapName, setMapName] = useState(initialData?.metadata?.name || "Untitled Project");
            const [nodes, setNodes] = useState(initialData?.nodes || []);
            const [edges, setEdges] = useState(initialData?.edges || []);
            const [mapImage, setMapImage] = useState(initialData?.metadata?.mapImage || null);
            const [view, setView] = useState({ scale: 1, x: 0, y: 0 });
            
            // UI State
            const [toolMode, setToolMode] = useState('select');
            const [selectedId, setSelectedId] = useState(null);
            const [isDeploying, setIsDeploying] = useState(false);
            
            // Refs
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const imgRef = useRef(null);
            const dragRef = useRef(null);
            const tempEdgeRef = useRef(null);
            const needsRender = useRef(true); 

            useEffect(() => {
                if (mapImage) {
                    const img = new Image();
                    img.src = mapImage;
                    img.onload = () => { imgRef.current = img; needsRender.current = true; };
                }
            }, [mapImage]);

            useEffect(() => { needsRender.current = true; }, [nodes, edges, view, selectedId, toolMode]);

            // --- RENDER LOOP ---
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                let animationFrameId;

                const render = () => {
                    if (needsRender.current) {
                        canvas.width = containerRef.current?.clientWidth || 800; 
                        canvas.height = containerRef.current?.clientHeight || 600;
                        ctx.clearRect(0,0,canvas.width,canvas.height); 
                        ctx.save();
                        ctx.translate(view.x, view.y); 
                        ctx.scale(view.scale, view.scale);
                        
                        // Background
                        if (imgRef.current) {
                            ctx.drawImage(imgRef.current, 0, 0);
                            ctx.beginPath(); ctx.strokeStyle = 'rgba(0,0,0,0.05)'; ctx.lineWidth=1/view.scale;
                            for(let x=0; x<=imgRef.current.width; x+=CONFIG.gridSize) { ctx.moveTo(x,0); ctx.lineTo(x,imgRef.current.height); }
                            for(let y=0; y<=imgRef.current.height; y+=CONFIG.gridSize) { ctx.moveTo(0,y); ctx.lineTo(imgRef.current.width,y); }
                            ctx.stroke();
                        }

                        // Edges
                        edges.forEach(e => {
                            const n1 = nodes.find(n=>n.id===e.from), n2 = nodes.find(n=>n.id===e.to);
                            if(n1 && n2) {
                                ctx.beginPath(); ctx.moveTo(n1.x, n1.y); ctx.lineTo(n2.x, n2.y);
                                ctx.strokeStyle = selectedId === e.id ? CONFIG.colors.selection : '#94a3b8';
                                ctx.lineWidth = (selectedId === e.id ? 4 : 2) / view.scale;
                                ctx.stroke();
                            }
                        });

                        // Nodes
                        nodes.forEach(n => {
                            const isSel = selectedId === n.id;
                            ctx.beginPath(); ctx.arc(n.x, n.y, (isSel ? 12 : 8)/view.scale, 0, Math.PI*2);
                            // FEATURE: Use Custom Color if set, else default
                            ctx.fillStyle = n.color || CONFIG.colors[n.type] || CONFIG.colors.walkable; 
                            ctx.fill();
                            if(isSel) { ctx.strokeStyle = '#fff'; ctx.lineWidth=2/view.scale; ctx.stroke(); }
                        });

                        // Temp Edge
                        if (tempEdgeRef.current) {
                            const start = nodes.find(n => n.id === tempEdgeRef.current.start);
                            if(start) {
                                ctx.beginPath(); ctx.moveTo(start.x, start.y); ctx.lineTo(tempEdgeRef.current.curr.x, tempEdgeRef.current.curr.y);
                                ctx.strokeStyle = '#94a3b8'; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
                            }
                        }

                        ctx.restore();
                        needsRender.current = false;
                    }
                    animationFrameId = requestAnimationFrame(render);
                };
                render();
                return () => cancelAnimationFrame(animationFrameId);
            }, [nodes, edges, view, selectedId]);

            // --- INTERACTION HANDLERS ---
            const handleMouseDown = (e) => {
                const rect = containerRef.current.getBoundingClientRect();
                const wPos = { x: (e.clientX - rect.left - view.x)/view.scale, y: (e.clientY - rect.top - view.y)/view.scale };
                const hitNode = nodes.find(n => Math.hypot(n.x - wPos.x, n.y - wPos.y) < CONFIG.hitRadius/view.scale);
                
                if (toolMode === 'pan' || e.button === 1) { dragRef.current = { type: 'pan', sx: e.clientX, sy: e.clientY, vStart: {...view} }; return; }
                
                if (toolMode === 'select') { 
                    if (hitNode) { setSelectedId(hitNode.id); dragRef.current = { type: 'move', id: hitNode.id }; } 
                    else {
                         // Check edges (simple AABB) - simplified for brevity
                         setSelectedId(null);
                    }
                }
                else if (toolMode === 'node') { 
                    if (hitNode) setSelectedId(hitNode.id); 
                    else { 
                        const id = UTILS.generateId(); 
                        setNodes([...nodes, { id, x: wPos.x, y: wPos.y, type: 'walkable', name: 'New Node', color: '' }]); 
                        setSelectedId(id); 
                    } 
                }
                else if (toolMode === 'edge' && hitNode) tempEdgeRef.current = { start: hitNode.id, curr: wPos };
                needsRender.current = true;
            };

            const handleMouseMove = (e) => {
                const rect = containerRef.current.getBoundingClientRect();
                const wPos = { x: (e.clientX - rect.left - view.x)/view.scale, y: (e.clientY - rect.top - view.y)/view.scale };
                
                if (dragRef.current?.type === 'pan') { 
                    const dx = e.clientX - dragRef.current.sx; const dy = e.clientY - dragRef.current.sy;
                    setView({ ...view, x: dragRef.current.vStart.x + dx, y: dragRef.current.vStart.y + dy });
                }
                else if (dragRef.current?.type === 'move') { 
                    setNodes(nodes.map(n => n.id === dragRef.current.id ? { ...n, x: wPos.x, y: wPos.y } : n)); 
                }
                else if (tempEdgeRef.current) { tempEdgeRef.current.curr = wPos; }
                needsRender.current = true;
            };

            const handleMouseUp = (e) => {
                const rect = containerRef.current.getBoundingClientRect();
                const wPos = { x: (e.clientX - rect.left - view.x)/view.scale, y: (e.clientY - rect.top - view.y)/view.scale };
                if (tempEdgeRef.current) {
                    const hitNode = nodes.find(n => Math.hypot(n.x - wPos.x, n.y - wPos.y) < CONFIG.hitRadius/view.scale);
                    if (hitNode && hitNode.id !== tempEdgeRef.current.start) {
                        setEdges([...edges, { id: UTILS.generateId(), from: tempEdgeRef.current.start, to: hitNode.id }]);
                    }
                    tempEdgeRef.current = null;
                }
                dragRef.current = null;
                needsRender.current = true;
            };

            const updateNode = (id, field, value) => {
                setNodes(nodes.map(n => n.id === id ? { ...n, [field]: value } : n));
            };

            const handleLogoUpload = (e, nodeId) => {
                const file = e.target.files[0];
                if (!file) return;
                // FEATURE: 100KB Limit
                if (file.size > 102400) { alert("Logo must be under 100KB"); return; }
                
                const reader = new FileReader();
                reader.onload = (evt) => updateNode(nodeId, 'logo', evt.target.result);
                reader.readAsDataURL(file);
            };

            const handleDeploy = async () => {
                if(!mapImage) return alert("Upload map first");
                setIsDeploying(true);
                try {
                    const mapData = { metadata: { version: "3.2", name: UTILS.sanitize(mapName), mapImage }, nodes, edges };
                    await deployToKiosk(mapData, initialData?.id || `map_${UTILS.generateId()}`, userId);
                    alert("Deployed! Check your Kiosk.");
                } catch(e) { alert("Error: " + e.message); }
                setIsDeploying(false);
            };

            const selectedNode = nodes.find(n => n.id === selectedId);

            return (
                <div className="flex flex-col h-full bg-white font-sans text-slate-800">
                    {/* Header */}
                    <div className="h-16 border-b border-slate-200 flex items-center justify-between px-6 z-20 bg-white">
                        <input value={mapName} onChange={(e) => setMapName(UTILS.sanitize(e.target.value))} className="font-bold text-lg outline-none" placeholder="Project Name" />
                        <button onClick={handleDeploy} disabled={isDeploying} className="bg-brand-600 text-white px-4 py-2 rounded-lg font-bold text-sm">
                            {isDeploying ? 'Deploying...' : 'Deploy to Kiosk'}
                        </button>
                    </div>

                    <div className="flex-1 flex overflow-hidden relative">
                        {/* Toolbar */}
                        <div className="w-16 border-r flex flex-col items-center py-4 gap-4 bg-white z-10">
                            {['select', 'node', 'edge', 'pan'].map(t => (
                                <button key={t} onClick={()=>setToolMode(t)} className={`w-10 h-10 rounded-lg flex items-center justify-center ${toolMode===t ? 'bg-blue-100 text-blue-600' : 'text-slate-400 hover:bg-slate-50'}`}>
                                    <Icon name={t === 'select' ? 'mouse-pointer' : t === 'node' ? 'circle-dot' : t === 'edge' ? 'draw-polygon' : 'hand'} />
                                </button>
                            ))}
                        </div>

                        {/* Canvas */}
                        <div className="flex-1 bg-slate-100 relative overflow-hidden cursor-crosshair" ref={containerRef} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onWheel={(e)=>{
                            setView(v => ({...v, scale: Math.max(0.1, v.scale*(1-e.deltaY*0.001))})); needsRender.current=true;
                        }}>
                            <canvas ref={canvasRef} className="block" />
                            {!mapImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="bg-white/80 p-6 rounded-xl">Upload Floor Plan ðŸ‘‡</div></div>}
                        </div>

                        {/* Right Sidebar (Properties) */}
                        <div className="w-80 bg-white border-l border-slate-200 flex flex-col shadow-xl z-10 overflow-y-auto">
                            <div className="p-4 border-b font-bold text-xs uppercase text-slate-500">Properties Panel</div>
                            <div className="p-4 space-y-4">
                                {selectedNode ? (
                                    <>
                                        <div>
                                            <label className="block text-xs font-bold mb-1">Name</label>
                                            <input type="text" value={selectedNode.name} onChange={(e)=>updateNode(selectedId, 'name', e.target.value)} className="w-full border p-2 rounded text-sm" />
                                        </div>
                                        
                                        <div>
                                            <label className="block text-xs font-bold mb-1">Type</label>
                                            <select value={selectedNode.type} onChange={(e)=>updateNode(selectedId, 'type', e.target.value)} className="w-full border p-2 rounded text-sm bg-white">
                                                {Object.keys(CONFIG.colors).map(k => <option key={k} value={k}>{k}</option>)}
                                                <option value="custom">Custom Type...</option>
                                            </select>
                                        </div>

                                        {/* FEATURE: Custom Type & Color */}
                                        {selectedNode.type === 'custom' && (
                                            <div className="bg-slate-50 p-3 rounded-lg border">
                                                <label className="block text-xs font-bold mb-1">Custom Type Name</label>
                                                <input type="text" placeholder="e.g. ATM, Medics" value={selectedNode.customTypeLabel || ''} onChange={(e)=>updateNode(selectedId, 'customTypeLabel', e.target.value)} className="w-full border p-2 rounded text-sm mb-2" />
                                                
                                                <label className="block text-xs font-bold mb-1">Node Color</label>
                                                <div className="flex items-center gap-2">
                                                    <input type="color" value={selectedNode.color || '#000000'} onChange={(e)=>updateNode(selectedId, 'color', e.target.value)} className="h-8 w-14 cursor-pointer" />
                                                    <span className="text-xs text-slate-500">Pick color</span>
                                                </div>
                                            </div>
                                        )}

                                        {/* FEATURE: Logo Upload */}
                                        <div>
                                            <label className="block text-xs font-bold mb-1">POI Logo (Max 100KB)</label>
                                            <div className="flex items-center gap-2">
                                                {selectedNode.logo && <img src={selectedNode.logo} className="w-10 h-10 object-contain border rounded bg-slate-50" />}
                                                <input type="file" accept="image/*" onChange={(e)=>handleLogoUpload(e, selectedId)} className="text-xs w-full" />
                                            </div>
                                            {selectedNode.logo && <button onClick={()=>updateNode(selectedId, 'logo', null)} className="text-xs text-red-500 mt-1">Remove Logo</button>}
                                        </div>

                                        {/* FEATURE: Description & Hours */}
                                        <div>
                                            <label className="block text-xs font-bold mb-1">Description</label>
                                            <textarea rows="3" value={selectedNode.description || ''} onChange={(e)=>updateNode(selectedId, 'description', e.target.value)} className="w-full border p-2 rounded text-sm" placeholder="Details about this location..." />
                                        </div>

                                        <div className="grid grid-cols-2 gap-2">
                                            <div>
                                                <label className="block text-xs font-bold mb-1">Open</label>
                                                <input type="time" value={selectedNode.openTime || ''} onChange={(e)=>updateNode(selectedId, 'openTime', e.target.value)} className="w-full border p-2 rounded text-sm" />
                                            </div>
                                            <div>
                                                <label className="block text-xs font-bold mb-1">Close</label>
                                                <input type="time" value={selectedNode.closeTime || ''} onChange={(e)=>updateNode(selectedId, 'closeTime', e.target.value)} className="w-full border p-2 rounded text-sm" />
                                            </div>
                                        </div>

                                        <div className="pt-4 border-t">
                                            <button onClick={()=>{setNodes(nodes.filter(n=>n.id!==selectedId)); setSelectedId(null);}} className="w-full bg-red-50 text-red-600 py-2 rounded text-xs font-bold">Delete Node</button>
                                        </div>
                                    </>
                                ) : (
                                    <div className="space-y-4">
                                        <div className="bg-blue-50 p-4 rounded-lg text-blue-800 text-sm">
                                            Select a node to edit properties, upload logos, or change colors.
                                        </div>
                                        <div>
                                            <label className="block text-xs font-bold mb-2">Upload Floor Plan</label>
                                            <input type="file" onChange={(e)=>{
                                                const file = e.target.files[0];
                                                if(file) {
                                                    const reader = new FileReader();
                                                    reader.onload = (evt) => { setMapImage(evt.target.result); setView({ scale: 0.5, x: 20, y: 20 }); };
                                                    reader.readAsDataURL(file);
                                                }
                                            }} accept="image/*" className="w-full text-sm" />
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const { user, loading } = useAuthStatus();
            return <ErrorBoundary>{!user ? <div className="h-screen flex items-center justify-center"><button onClick={()=>window.location.href='index.html'} className="bg-blue-600 text-white px-6 py-3 rounded-lg font-bold">Login to Studio</button></div> : <Editor userId={user.uid} />}</ErrorBoundary>;
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    
    </script>
</body>
</html>
