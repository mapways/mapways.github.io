<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wayfinder Studio Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <!-- FIREBASE SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
        
        canvas { cursor: crosshair; }
        .glass-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .tool-btn.active {
            background-color: #3b82f6; /* Blue 500 */
            color: white;
            border-color: #2563eb;
        }
        /* Preview Mode Pulse */
        @keyframes pulse-ring { 0% { transform: scale(0.33); opacity: 1; } 80%, 100% { transform: scale(1.5); opacity: 0; } }
        .preview-active { border: 4px solid #10b981; }
    </style>
</head>
<body class="h-screen flex flex-col bg-slate-100 text-slate-800 font-sans">

    <!-- Navbar -->
    <div class="bg-gradient-to-r from-slate-900 to-slate-800 text-white p-3 flex justify-between items-center shadow-lg z-20">
        <div class="flex items-center space-x-3">
            <div class="bg-blue-600 p-2 rounded-lg">
                <i class="fas fa-map-signs text-white"></i>
            </div>
            <div>
                <h1 class="text-lg font-bold tracking-wide">Wayfinder Studio <span class="text-xs bg-green-500 text-white px-2 py-0.5 rounded-full ml-1">Cloud Connected</span></h1>
                <p class="text-xs text-slate-400">Digital Wayfinding System Manager</p>
            </div>
        </div>
        
        <div class="flex items-center space-x-3">
             <!-- Local Backup Controls -->
             <div class="flex bg-slate-700/50 rounded-lg p-1 mr-4 space-x-1">
                <button onclick="downloadJSON()" class="px-3 py-1.5 hover:bg-slate-600 rounded text-xs text-slate-300 transition" title="Backup to PC">
                    <i class="fas fa-download mr-1"></i> Export
                </button>
                <label class="px-3 py-1.5 hover:bg-slate-600 rounded text-xs text-slate-300 transition cursor-pointer" title="Load from PC">
                    <i class="fas fa-upload mr-1"></i> Import
                    <input type="file" onchange="importJSON(this)" accept=".json" class="hidden">
                </label>
             </div>

             <!-- Simulation -->
             <button onclick="togglePreviewMode()" id="btn-preview" class="flex items-center space-x-2 px-3 py-1.5 bg-slate-600 hover:bg-slate-500 text-white rounded shadow text-sm transition font-medium border border-slate-500">
                <i class="fas fa-play"></i>
                <span>Preview</span>
            </button>

             <div class="h-6 w-px bg-slate-600 mx-2"></div>

             <span id="save-status" class="text-xs text-slate-400 italic mr-2 hidden md:inline"></span>
             <button onclick="saveToCloud()" class="flex items-center space-x-2 px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 text-white rounded shadow-lg text-sm transition font-medium">
                <i class="fas fa-cloud-upload-alt"></i>
                <span>Save Cloud</span>
            </button>
            <button onclick="toggleDeployMenu()" class="flex items-center space-x-2 px-3 py-1.5 bg-green-600 hover:bg-green-500 text-white rounded shadow-lg text-sm transition font-medium">
                <i class="fas fa-qrcode"></i>
                <span>Connect</span>
            </button>
        </div>
    </div>

    <!-- Main Layout -->
    <div class="flex flex-1 overflow-hidden relative">
        
        <!-- Left Sidebar: Tools & Properties -->
        <div id="sidebar" class="w-80 bg-white border-r border-slate-200 flex flex-col shadow-xl z-10 transition-transform duration-300">
            
            <!-- Toolbar Mode Selector -->
            <div class="p-4 border-b border-slate-100 bg-slate-50">
                <label class="text-xs font-bold text-slate-500 uppercase tracking-wider mb-2 block">Tools</label>
                <div class="grid grid-cols-4 gap-2">
                    <button onclick="setMode('select')" id="btn-select" class="tool-btn p-2 rounded border border-slate-200 hover:bg-white bg-slate-100 flex flex-col items-center justify-center transition" title="Select (V)">
                        <i class="fas fa-mouse-pointer mb-1 text-lg"></i>
                        <span class="text-[10px] font-medium">Select</span>
                    </button>
                    <button onclick="setMode('node')" id="btn-node" class="tool-btn p-2 rounded border border-slate-200 hover:bg-white bg-slate-100 flex flex-col items-center justify-center transition" title="Add Nodes (N)">
                        <i class="fas fa-dot-circle mb-1 text-lg"></i>
                        <span class="text-[10px] font-medium">Node</span>
                    </button>
                    <button onclick="setMode('edge')" id="btn-edge" class="tool-btn p-2 rounded border border-slate-200 hover:bg-white bg-slate-100 flex flex-col items-center justify-center transition" title="Connect (C)">
                        <i class="fas fa-bezier-curve mb-1 text-lg"></i>
                        <span class="text-[10px] font-medium">Edge</span>
                    </button>
                    <button onclick="setMode('pan')" id="btn-pan" class="tool-btn p-2 rounded border border-slate-200 hover:bg-white bg-slate-100 flex flex-col items-center justify-center transition" title="Pan (Space)">
                        <i class="fas fa-hand-paper mb-1 text-lg"></i>
                        <span class="text-[10px] font-medium">Pan</span>
                    </button>
                </div>
            </div>

            <div class="flex-1 overflow-y-auto p-4 space-y-6">
                
                <!-- Upload Section -->
                <div>
                    <label class="text-xs font-bold text-slate-500 uppercase tracking-wider mb-2 block">Map Source</label>
                    <div class="relative group">
                        <input type="file" id="imageLoader" accept="image/*" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10" />
                        <div class="border-2 border-dashed border-slate-300 rounded bg-slate-50 p-4 text-center group-hover:border-blue-400 group-hover:bg-blue-50 transition">
                            <p class="text-sm text-slate-600 font-medium">Click to Upload Map</p>
                            <p class="text-xs text-slate-400 mt-1">JPG, PNG, SVG</p>
                        </div>
                    </div>
                </div>

                <!-- Settings -->
                <div>
                     <label class="text-xs font-bold text-slate-500 uppercase tracking-wider mb-2 block">View Settings</label>
                     <div class="space-y-2">
                        <label class="flex items-center space-x-2 text-sm text-slate-700 cursor-pointer">
                            <input type="checkbox" id="chk-grid" onchange="toggleGrid()" class="rounded text-blue-600 focus:ring-blue-500">
                            <span>Show Grid</span>
                        </label>
                        <label class="flex items-center space-x-2 text-sm text-slate-700 cursor-pointer">
                            <input type="checkbox" id="chk-snap" onchange="toggleSnap()" class="rounded text-blue-600 focus:ring-blue-500">
                            <span>Snap to Grid</span>
                        </label>
                        <label class="flex items-center space-x-2 text-sm text-slate-700 cursor-pointer">
                            <input type="checkbox" id="chk-labels" checked onchange="draw()" class="rounded text-blue-600 focus:ring-blue-500">
                            <span>Show Labels</span>
                        </label>
                     </div>
                </div>

                <!-- DYNAMIC PROPERTY PANEL -->
                
                <!-- 1. Node Properties -->
                <div id="prop-panel-node" class="hidden bg-white border border-slate-200 rounded-lg shadow-sm overflow-hidden animate-fade-in">
                    <div class="bg-blue-50 border-b border-blue-100 p-3 flex justify-between items-center">
                        <h3 class="font-bold text-blue-800 text-sm">üìç Point Details</h3>
                        <span class="text-[10px] bg-blue-200 text-blue-800 px-1.5 py-0.5 rounded" id="prop-node-id">ID</span>
                    </div>
                    <div class="p-3 space-y-3">
                        <div>
                            <label class="block text-xs font-medium text-slate-500 mb-1">Name / Label</label>
                            <input type="text" id="node-name" class="w-full border border-slate-300 p-2 text-sm rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none" placeholder="e.g. Starbucks">
                        </div>
                        <div>
                            <label class="block text-xs font-medium text-slate-500 mb-1">Type</label>
                            <select id="node-type" class="w-full border border-slate-300 p-2 text-sm rounded focus:ring-2 focus:ring-blue-500 outline-none bg-white">
                                <option value="walkable">Walkable Path</option>
                                <option value="destination">Destination (Shop/Room)</option>
                                <option value="kiosk">Kiosk Location (Start)</option>
                                <option value="bathroom">Restroom</option>
                                <option value="exit">Exit / Elevator</option>
                                <option value="stairs">Stairs / Escalator</option>
                                <option value="parking">Parking</option>
                            </select>
                        </div>
                         <div>
                            <label class="block text-xs font-medium text-slate-500 mb-1">Description</label>
                            <textarea id="node-desc" rows="2" class="w-full border border-slate-300 p-2 text-sm rounded focus:ring-2 focus:ring-blue-500 outline-none" placeholder="Extra details..."></textarea>
                        </div>
                        <div class="pt-2 flex space-x-2">
                             <button onclick="saveNodeDetails()" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-2 rounded transition">Update</button>
                             <button onclick="deleteSelected()" class="flex-1 bg-white border border-red-200 text-red-600 hover:bg-red-50 text-xs font-bold py-2 rounded transition">Delete</button>
                        </div>
                    </div>
                </div>

                <!-- 2. Edge Properties -->
                <div id="prop-panel-edge" class="hidden bg-white border border-slate-200 rounded-lg shadow-sm overflow-hidden animate-fade-in">
                    <div class="bg-indigo-50 border-b border-indigo-100 p-3">
                        <h3 class="font-bold text-indigo-800 text-sm">üîó Connection Details</h3>
                    </div>
                    <div class="p-3 space-y-3">
                         <div class="flex items-center justify-between">
                             <span class="text-xs text-slate-500">Distance</span>
                             <span id="edge-dist-display" class="text-sm font-mono font-bold">0 px</span>
                         </div>
                         <div>
                             <label class="block text-xs font-medium text-slate-500 mb-1">Weight / Difficulty</label>
                             <input type="number" id="edge-weight" value="1" min="1" class="w-full border border-slate-300 p-2 text-sm rounded">
                             <p class="text-[10px] text-slate-400 mt-1">Higher = harder to walk (e.g. stairs)</p>
                         </div>
                         <div class="flex items-center space-x-2">
                            <input type="checkbox" id="edge-accessible" class="rounded text-indigo-600">
                            <label for="edge-accessible" class="text-sm text-slate-700">Wheelchair Accessible</label>
                         </div>
                         <div class="pt-2 flex space-x-2">
                             <button onclick="saveEdgeDetails()" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white text-xs font-bold py-2 rounded transition">Update</button>
                             <button onclick="deleteSelected()" class="flex-1 bg-white border border-red-200 text-red-600 hover:bg-red-50 text-xs font-bold py-2 rounded transition">Delete</button>
                        </div>
                    </div>
                </div>

            </div>

            <!-- Stats Footer -->
            <div class="p-3 bg-slate-50 border-t border-slate-200 text-xs text-slate-500 grid grid-cols-2 gap-2">
                <div>Nodes: <span id="stat-nodes" class="font-bold text-slate-700">0</span></div>
                <div>Edges: <span id="stat-edges" class="font-bold text-slate-700">0</span></div>
            </div>
        </div>

        <!-- Canvas Workspace -->
        <div class="flex-1 bg-slate-200 relative overflow-hidden cursor-crosshair" id="canvas-container">
            
            <!-- Floating Controls -->
            <div class="absolute bottom-6 right-6 flex flex-col space-y-2 z-20">
                <div class="glass-panel p-1 rounded-lg shadow-lg flex flex-col space-y-1">
                    <button onclick="handleZoom(1.1)" class="p-2 hover:bg-white rounded text-slate-600 transition" title="Zoom In">+</button>
                    <button onclick="resetView()" class="p-2 hover:bg-white rounded text-slate-600 transition text-xs font-bold" title="Reset View">100%</button>
                    <button onclick="handleZoom(0.9)" class="p-2 hover:bg-white rounded text-slate-600 transition" title="Zoom Out">-</button>
                </div>
                <div class="glass-panel p-1 rounded-lg shadow-lg">
                    <button onclick="undo()" class="p-2 hover:bg-white rounded text-slate-600 w-full transition" title="Undo (Ctrl+Z)">
                        <i class="fas fa-undo"></i>
                    </button>
                </div>
                 <div class="glass-panel p-1 rounded-lg shadow-lg">
                    <button onclick="clearAll()" class="p-2 hover:bg-red-50 text-red-500 rounded w-full transition" title="Clear All">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>

            <!-- Preview Mode Overlay Message -->
            <div id="preview-overlay" class="absolute top-6 left-1/2 transform -translate-x-1/2 bg-slate-900/90 text-white px-6 py-3 rounded-full shadow-xl z-30 hidden flex items-center space-x-3 pointer-events-none">
                <div class="w-3 h-3 bg-green-500 rounded-full animate-pulse"></div>
                <span class="font-bold">Preview Mode Active</span>
                <span class="text-xs text-slate-400 border-l border-slate-600 pl-3">Click any destination to test path</span>
            </div>

            <canvas id="mapCanvas" class="bg-white shadow-2xl block"></canvas>
            
            <!-- Empty State Helper -->
            <div id="empty-state" class="absolute inset-0 flex items-center justify-center pointer-events-none">
                <div class="bg-white/80 backdrop-blur p-6 rounded-xl shadow-xl text-center">
                    <div class="text-4xl mb-2">üó∫Ô∏è</div>
                    <h2 class="text-lg font-bold text-slate-700">Ready to Start?</h2>
                    <p class="text-sm text-slate-500">Upload a floor plan from the sidebar to begin.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- DEPLOY / CONNECT MODAL -->
    <div id="deploy-modal" class="hidden fixed inset-0 bg-slate-900/50 z-50 flex items-center justify-center backdrop-blur-sm">
        <div class="bg-white rounded-2xl shadow-2xl p-6 w-96">
            <h2 class="text-xl font-bold mb-4 flex items-center">
                <i class="fas fa-satellite-dish text-green-500 mr-2"></i> Connect Device
            </h2>
            <p class="text-sm text-slate-500 mb-4">Generate a unique code to pair an Android Kiosk to this map.</p>
            
            <div id="code-display-area" class="hidden mb-6 text-center">
                <div class="text-4xl font-mono font-bold text-slate-800 bg-slate-100 p-4 rounded-lg border-2 border-dashed border-slate-300 tracking-widest" id="generated-code">
                    ---
                </div>
                <p class="text-xs text-orange-500 mt-2 font-medium">Valid for 10 minutes. Single use only.</p>
            </div>

            <button onclick="generatePairingCode()" id="btn-gen-code" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg transition">
                Generate New Code
            </button>
            <button onclick="toggleDeployMenu()" class="w-full mt-2 text-slate-400 text-sm hover:text-slate-600">Close</button>
        </div>
    </div>

    <script>
        // ==========================================
        // üîß CONFIGURATION SECTION
        // ==========================================
        const firebaseConfig = {
  apiKey: "AIzaSyDWJ5qVnsA3rWvfkc0-_cIyfwLHEZNMuxE",
  authDomain: "wayfinder-app-a2565.firebaseapp.com",
  projectId: "wayfinder-app-a2565",
  storageBucket: "wayfinder-app-a2565.firebasestorage.app",
  messagingSenderId: "770872636942",
  appId: "1:770872636942:web:f342a0d96de313a19a6e5f",
  measurementId: "G-W7BXXBPLGX"
};

        const IMGBB_API_KEY = "d3c464ab1b35134225f0bf7787c09d16"; 
        // ==========================================

        // Initialize Firebase
        try {
            firebase.initializeApp(firebaseConfig);
            var db = firebase.firestore();
            console.log("Firebase initialized");
        } catch(e) {
            console.warn("Firebase config missing or error", e);
        }

        // --- EDITOR CONFIG & STATE ---
        const CONFIG = {
            gridSize: 40,
            pointRadius: 6,
            selectionColor: '#fbbf24', 
            nodeColors: {
                walkable: '#3b82f6', destination: '#10b981', kiosk: '#ef4444',
                bathroom: '#8b5cf6', exit: '#f97316', stairs: '#ec4899', parking: '#64748b'
            }
        };

        let img = new Image();
        let nodes = [];
        let edges = [];
        let scale = 1;
        let offset = { x: 0, y: 0 };
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };
        let mode = 'select';
        let previousMode = 'select'; // Remembers mode before preview
        let selectedElement = null;
        let tempEdgeStart = null;
        let history = [];
        let showGrid = false;
        let snapToGrid = false;
        let currentMapId = "map_" + Date.now(); 
        let previewPath = null; // Stores Dijkstra result for preview

        const container = document.getElementById('canvas-container');
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');

        // --- INITIALIZATION ---
        new ResizeObserver(() => { fitCanvasToContainer(); draw(); }).observe(container);

        function fitCanvasToContainer() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        // --- NEW: EXPORT / IMPORT JSON ---
        function downloadJSON() {
            const data = {
                metadata: {
                    version: "2.1",
                    generated: new Date().toISOString(),
                    mapImage: img.src.startsWith('data:') ? null : img.src // Only export URL if remote, otherwise skipped to save space
                },
                nodes: nodes,
                edges: edges
            };
            // Alert user about image if it's local
            if (img.src.startsWith('data:')) {
                alert("Note: The map image itself is not included in the JSON backup to keep the file small. You will need to re-upload the image file when importing.");
            }

            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
            const dl = document.createElement('a');
            dl.setAttribute("href", dataStr);
            dl.setAttribute("download", `wayfinder_backup_${Date.now()}.json`);
            dl.click();
        }

        function importJSON(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.nodes && data.edges) {
                        pushHistory();
                        nodes = data.nodes;
                        edges = data.edges;
                        // Try to load image if URL exists
                        if (data.metadata.mapImage) {
                            img.src = data.metadata.mapImage;
                        } else {
                            alert("Map Data Loaded! Please re-upload your floor plan image to see the layout.");
                        }
                        updateStats();
                        draw();
                    } else { alert("Invalid JSON format"); }
                } catch(err) { alert("Error parsing JSON"); }
            };
            reader.readAsText(file);
        }

        // --- NEW: PREVIEW MODE (DIJKSTRA) ---
        
        function togglePreviewMode() {
            const btn = document.getElementById('btn-preview');
            const overlay = document.getElementById('preview-overlay');
            const sidebar = document.getElementById('sidebar');

            if (mode === 'preview') {
                // EXIT PREVIEW
                mode = previousMode;
                btn.classList.remove('bg-green-600', 'border-green-500');
                btn.classList.add('bg-slate-600', 'border-slate-500');
                btn.innerHTML = '<i class="fas fa-play"></i><span>Preview</span>';
                overlay.classList.add('hidden');
                sidebar.classList.remove('opacity-50', 'pointer-events-none');
                previewPath = null;
                setMode(previousMode); // Restore tools
            } else {
                // ENTER PREVIEW
                const kiosk = nodes.find(n => n.type === 'kiosk');
                if (!kiosk) { alert("You must add a 'Kiosk Location' point first!"); return; }

                previousMode = mode;
                mode = 'preview';
                
                btn.classList.remove('bg-slate-600', 'border-slate-500');
                btn.classList.add('bg-green-600', 'border-green-500');
                btn.innerHTML = '<i class="fas fa-stop"></i><span>Stop</span>';
                overlay.classList.remove('hidden');
                sidebar.classList.add('opacity-50', 'pointer-events-none');
                
                selectedElement = null;
                updateUI();
                draw();
            }
        }

        // Simple Dijkstra for Preview
        function calculatePath(endNodeId) {
            const startNode = nodes.find(n => n.type === 'kiosk');
            if (!startNode) return;

            // 1. Build Adjacency Graph
            const graph = {};
            nodes.forEach(n => graph[n.id] = []);
            edges.forEach(e => {
                const dist = Math.hypot(
                    nodes.find(n=>n.id===e.from).x - nodes.find(n=>n.id===e.to).x,
                    nodes.find(n=>n.id===e.from).y - nodes.find(n=>n.id===e.to).y
                );
                graph[e.from].push({ node: e.to, weight: (e.weight || 1) * dist });
                graph[e.to].push({ node: e.from, weight: (e.weight || 1) * dist });
            });

            // 2. Dijkstra
            const dists = {};
            const prev = {};
            const pq = new Set(nodes.map(n => n.id));
            
            nodes.forEach(n => dists[n.id] = Infinity);
            dists[startNode.id] = 0;

            while (pq.size > 0) {
                // Find min dist
                let u = null;
                for (const node of pq) {
                    if (!u || dists[node] < dists[u]) u = node;
                }
                if (u === endNodeId) break; // Found target
                
                pq.delete(u);
                
                if (dists[u] === Infinity) break;

                const neighbors = graph[u] || [];
                for (const neighbor of neighbors) {
                    if (pq.has(neighbor.node)) {
                        const alt = dists[u] + neighbor.weight;
                        if (alt < dists[neighbor.node]) {
                            dists[neighbor.node] = alt;
                            prev[neighbor.node] = u;
                        }
                    }
                }
            }

            // 3. Reconstruct
            const path = [];
            let u = endNodeId;
            if (prev[u] || u === startNode.id) {
                while (u) {
                    const node = nodes.find(n => n.id === u);
                    path.unshift(node);
                    u = prev[u];
                }
            }
            return path.length > 1 ? path : null;
        }


        // --- CLOUD SYNC & IMAGE UPLOAD ---

        function toggleDeployMenu() {
            const modal = document.getElementById('deploy-modal');
            modal.classList.toggle('hidden');
            document.getElementById('code-display-area').classList.add('hidden');
            document.getElementById('btn-gen-code').innerText = "Generate New Code";
        }

        async function uploadToImgBB(base64Image) {
            const formData = new FormData();
            const cleanBase64 = base64Image.split(',')[1];
            formData.append('image', cleanBase64);

            const response = await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_API_KEY}`, {
                method: 'POST', body: formData
            });

            const result = await response.json();
            if (result.success) return result.data.url;
            throw new Error(result.error ? result.error.message : 'Upload failed');
        }

        async function saveToCloud() {
            const btn = document.querySelector('button[onclick="saveToCloud()"]');
            const originalText = btn.innerHTML;
            btn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Processing...`;
            
            let finalImageUrl = img.src;
            if (finalImageUrl.startsWith('data:')) {
                btn.innerHTML = `<i class="fas fa-cloud-upload-alt fa-bounce"></i> Uploading Image...`;
                try {
                    if (IMGBB_API_KEY.includes("YOUR")) {
                        alert("Please configure ImgBB API Key!"); btn.innerHTML = originalText; return;
                    }
                    finalImageUrl = await uploadToImgBB(finalImageUrl);
                    img.src = finalImageUrl; 
                } catch (err) {
                    alert("Image Upload Failed: " + err.message + "\n\nTry using the 'Export' button to save locally instead.");
                    btn.innerHTML = originalText;
                    return;
                }
            }

            const mapData = {
                metadata: { version: "2.1", generated: new Date().toISOString(), mapImage: finalImageUrl },
                nodes: nodes,
                edges: edges
            };

            try {
                btn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Saving DB...`;
                // Add Timeout wrapper
                const savePromise = db.collection("maps").doc(currentMapId).set(mapData);
                const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error("Request timed out")), 10000));
                
                await Promise.race([savePromise, timeoutPromise]);
                
                document.getElementById('save-status').innerText = "Saved " + new Date().toLocaleTimeString();
                btn.innerHTML = `<i class="fas fa-check"></i> Saved`;
                setTimeout(() => btn.innerHTML = originalText, 2000);
            } catch (error) {
                console.error("Save error: ", error);
                alert("Cloud Save Error: " + error.message + "\n\nPlease use the 'Export' button to save your work locally!");
                btn.innerHTML = originalText;
            }
        }

        async function generatePairingCode() {
            await saveToCloud();
            const code = Math.random().toString(36).substring(2, 8).toUpperCase();
            try {
                await db.collection("pairing_codes").doc(code).set({
                    code: code, mapId: currentMapId, status: "waiting",
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                document.getElementById('code-display-area').classList.remove('hidden');
                document.getElementById('generated-code').innerText = code;
                document.getElementById('btn-gen-code').innerText = "Regenerate";
            } catch (error) { alert("Error: " + error.message); }
        }


        // --- CORE EDITOR LOGIC ---
        
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            if (mode === 'preview') return; // Disable shortcuts in preview
            if (e.key === 'z' && (e.ctrlKey || e.metaKey)) undo();
            if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
            if (e.key === ' ') setMode('pan');
            if (e.key === 'v') setMode('select');
            if (e.key === 'n') setMode('node');
            if (e.key === 'c') setMode('edge');
        });

        function pushHistory() {
            if (history.length > 20) history.shift();
            history.push(JSON.stringify({ nodes, edges }));
        }

        function undo() {
            if (history.length === 0) return;
            const previous = JSON.parse(history.pop());
            nodes = previous.nodes; edges = previous.edges;
            selectedElement = null; tempEdgeStart = null; previewPath = null;
            updateUI(); draw();
        }

        function clearAll() {
            if(confirm("Clear map?")) {
                pushHistory();
                nodes = []; edges = []; selectedElement = null; img.src = "";
                document.getElementById('empty-state').classList.remove('hidden');
                draw(); updateUI();
            }
        }

        function toWorld(x, y) { return { x: (x - offset.x) / scale, y: (y - offset.y) / scale }; }
        function toScreen(x, y) { return { x: (x * scale) + offset.x, y: (y * scale) + offset.y }; }
        function applySnap(val) { return !snapToGrid ? val : Math.round(val / CONFIG.gridSize) * CONFIG.gridSize; }

        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = -e.deltaY * 0.001;
            const newScale = Math.min(Math.max(0.1, scale + delta), 5);
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const worldBefore = toWorld(mouseX, mouseY);
            scale = newScale;
            const worldAfter = toScreen(worldBefore.x, worldBefore.y);
            offset.x += mouseX - worldAfter.x; offset.y += mouseY - worldAfter.y;
            draw();
        });

        container.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const worldPos = toWorld(e.clientX - rect.left, e.clientY - rect.top);

            if (mode === 'preview') {
                // PREVIEW INTERACTION
                const clickedNode = nodes.slice().reverse().find(n => Math.hypot(n.x - worldPos.x, n.y - worldPos.y) < (CONFIG.pointRadius + 10) / scale);
                if (clickedNode) {
                    previewPath = calculatePath(clickedNode.id);
                    draw();
                }
                return;
            }

            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };

            if (mode === 'pan' || e.button === 1) { container.style.cursor = 'grabbing'; return; }

            const clickedNode = nodes.slice().reverse().find(n => Math.hypot(n.x - worldPos.x, n.y - worldPos.y) < (CONFIG.pointRadius + 5) / scale + 5);
            if (clickedNode) {
                if (mode === 'edge') {
                    if (!tempEdgeStart) tempEdgeStart = clickedNode.id;
                    else if (tempEdgeStart !== clickedNode.id) {
                        pushHistory();
                        if (!edges.some(e => (e.from === tempEdgeStart && e.to === clickedNode.id) || (e.from === clickedNode.id && e.to === tempEdgeStart))) {
                             edges.push({ id: Date.now().toString(), from: tempEdgeStart, to: clickedNode.id, weight: 1, accessible: true });
                        }
                        tempEdgeStart = null; updateStats();
                    }
                } else { selectElement('node', clickedNode.id); }
                draw(); return;
            }

            if (mode === 'node') {
                pushHistory();
                const id = Date.now().toString();
                nodes.push({ id, x: applySnap(worldPos.x), y: applySnap(worldPos.y), type: 'walkable', name: '' });
                selectElement('node', id);
                updateStats(); draw();
            } else {
                selectedElement = null; tempEdgeStart = null; updateUI(); draw();
            }
        });

        container.addEventListener('mousemove', (e) => {
            const dx = e.clientX - lastMouse.x;
            const dy = e.clientY - lastMouse.y;
            lastMouse = { x: e.clientX, y: e.clientY };

            if (isDragging) {
                if (mode === 'pan' || e.buttons === 4) {
                    offset.x += dx; offset.y += dy; draw();
                } else if (mode === 'select' && selectedElement && selectedElement.type === 'node') {
                    const node = nodes.find(n => n.id === selectedElement.id);
                    if (node) {
                        const worldPos = toWorld(e.clientX - container.getBoundingClientRect().left, e.clientY - container.getBoundingClientRect().top);
                        node.x = applySnap(worldPos.x); node.y = applySnap(worldPos.y); draw();
                    }
                }
            }
        });

        container.addEventListener('mouseup', () => { isDragging = false; container.style.cursor = mode === 'pan' ? 'grab' : 'crosshair'; });

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offset.x, offset.y);
            ctx.scale(scale, scale);

            if (img.src) ctx.drawImage(img, 0, 0);
            if (showGrid && mode !== 'preview') drawGrid();

            // Draw Edges
            edges.forEach(edge => {
                const n1 = nodes.find(n => n.id === edge.from);
                const n2 = nodes.find(n => n.id === edge.to);
                if (n1 && n2) {
                    ctx.beginPath(); ctx.moveTo(n1.x, n1.y); ctx.lineTo(n2.x, n2.y);
                    const isSelected = selectedElement?.type === 'edge' && selectedElement.id === edge.id;
                    ctx.lineWidth = isSelected ? 4 : 2;
                    ctx.strokeStyle = isSelected ? CONFIG.selectionColor : (mode === 'preview' ? 'rgba(148, 163, 184, 0.4)' : '#94a3b8'); // Fade edges in preview
                    if (!edge.accessible) ctx.setLineDash([5, 5]); else ctx.setLineDash([]);
                    ctx.stroke();
                }
            });

            // Draw Preview Path
            if (mode === 'preview' && previewPath) {
                ctx.beginPath();
                ctx.lineWidth = 6;
                ctx.strokeStyle = '#2563eb'; // Blue active path
                ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                ctx.setLineDash([]);
                ctx.moveTo(previewPath[0].x, previewPath[0].y);
                for(let i=1; i<previewPath.length; i++) ctx.lineTo(previewPath[i].x, previewPath[i].y);
                ctx.stroke();
            }

            if (mode === 'edge' && tempEdgeStart) {
                const n1 = nodes.find(n => n.id === tempEdgeStart);
                if(n1) { ctx.beginPath(); ctx.arc(n1.x, n1.y, CONFIG.pointRadius*1.5,0,Math.PI*2); ctx.strokeStyle=CONFIG.selectionColor; ctx.stroke();}
            }

            // Draw Nodes
            nodes.forEach(node => {
                // In preview, only show destination/kiosk distinctively
                if (mode === 'preview' && node.type === 'walkable') return; 

                ctx.beginPath();
                const isSelected = selectedElement?.type === 'node' && selectedElement.id === node.id;
                ctx.arc(node.x, node.y, isSelected ? CONFIG.pointRadius*1.5 : CONFIG.pointRadius, 0, Math.PI * 2);
                ctx.fillStyle = CONFIG.nodeColors[node.type] || CONFIG.nodeColors.walkable;
                ctx.fill(); 
                
                if (mode !== 'preview') {
                    ctx.strokeStyle = isSelected ? CONFIG.selectionColor : 'white'; ctx.lineWidth = 1.5; ctx.stroke();
                }

                if (node.name && (document.getElementById('chk-labels').checked || mode === 'preview')) {
                    ctx.font = 'bold 10px sans-serif'; ctx.fillStyle = '#1e293b'; ctx.textAlign = 'center'; 
                    // Add background for readability in preview
                    if (mode === 'preview') {
                         ctx.shadowColor="white"; ctx.shadowBlur=4;
                    }
                    ctx.fillText(node.name, node.x, node.y - 12);
                    ctx.shadowBlur=0;
                }
            });
            ctx.restore();
        }

        function drawGrid() {
            if (!img.src) return;
            const w = img.width, h = img.height, step = CONFIG.gridSize;
            ctx.beginPath(); ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)'; ctx.lineWidth = 1;
            for (let x = 0; x <= w; x += step) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
            for (let y = 0; y <= h; y += step) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
            ctx.stroke();
        }

        document.getElementById('imageLoader').addEventListener('change', function(e) {
            const reader = new FileReader();
            reader.onload = function(event) {
                img.onload = function() {
                    scale = 1; offset = {x:0, y:0};
                    const containerAspect = container.clientWidth / container.clientHeight;
                    const imgAspect = img.width / img.height;
                    scale = (imgAspect > containerAspect) ? (container.clientWidth - 40) / img.width : (container.clientHeight - 40) / img.height;
                    offset.x = (container.clientWidth - img.width * scale) / 2;
                    offset.y = (container.clientHeight - img.height * scale) / 2;
                    document.getElementById('empty-state').classList.add('hidden'); draw();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(e.target.files[0]);
        });

        function setMode(newMode) {
            mode = newMode;
            if (mode !== 'preview') {
                ['select', 'node', 'edge', 'pan'].forEach(m => {
                    const btn = document.getElementById('btn-' + m);
                    if (m === newMode) btn.classList.add('active', 'border-blue-500'); else btn.classList.remove('active', 'border-blue-500');
                });
            }
            container.style.cursor = mode === 'pan' ? 'grab' : 'crosshair'; tempEdgeStart = null; draw();
        }
        function toggleGrid() { showGrid = document.getElementById('chk-grid').checked; draw(); }
        function toggleSnap() { snapToGrid = document.getElementById('chk-snap').checked; }
        function resetView() { scale = 1; offset = { x: 50, y: 50 }; draw(); }
        function handleZoom(m) { scale *= m; draw(); }
        function selectElement(type, id) { selectedElement = { type, id }; updateUI(); }
        
        function updateUI() {
            const nodePanel = document.getElementById('prop-panel-node');
            const edgePanel = document.getElementById('prop-panel-edge');
            nodePanel.classList.add('hidden'); edgePanel.classList.add('hidden');
            if (selectedElement?.type === 'node') {
                const node = nodes.find(n => n.id === selectedElement.id);
                if (node) {
                    nodePanel.classList.remove('hidden');
                    document.getElementById('prop-node-id').innerText = '#' + node.id.substr(-4);
                    document.getElementById('node-name').value = node.name || '';
                    document.getElementById('node-type').value = node.type;
                    document.getElementById('node-desc').value = node.description || '';
                }
            } else if (selectedElement?.type === 'edge') {
                const edge = edges.find(e => e.id === selectedElement.id);
                if (edge) {
                    edgePanel.classList.remove('hidden');
                    const n1 = nodes.find(n => n.id === edge.from), n2 = nodes.find(n => n.id === edge.to);
                    document.getElementById('edge-dist-display').innerText = Math.round(Math.hypot(n1.x - n2.x, n1.y - n2.y)) + ' px';
                    document.getElementById('edge-weight').value = edge.weight || 1;
                    document.getElementById('edge-accessible').checked = edge.accessible !== false;
                }
            }
        }
        function saveNodeDetails() {
            if (selectedElement?.type !== 'node') return;
            const node = nodes.find(n => n.id === selectedElement.id);
            if (node) { pushHistory(); node.name = document.getElementById('node-name').value; node.type = document.getElementById('node-type').value; node.description = document.getElementById('node-desc').value; draw(); }
        }
        function saveEdgeDetails() {
             if (selectedElement?.type !== 'edge') return;
             const edge = edges.find(e => e.id === selectedElement.id);
             if (edge) { pushHistory(); edge.weight = parseInt(document.getElementById('edge-weight').value); edge.accessible = document.getElementById('edge-accessible').checked; draw(); }
        }
        function deleteSelected() {
            if (!selectedElement) return;
            pushHistory();
            if (selectedElement.type === 'node') {
                nodes = nodes.filter(n => n.id !== selectedElement.id);
                edges = edges.filter(e => e.from !== selectedElement.id && e.to !== selectedElement.id);
            } else { edges = edges.filter(e => e.id !== selectedElement.id); }
            selectedElement = null; updateUI(); updateStats(); draw();
        }
        function updateStats() {
            document.getElementById('stat-nodes').innerText = nodes.length;
            document.getElementById('stat-edges').innerText = edges.length;
        }

        setMode('select');
    </script>
</body>
</html>
