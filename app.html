<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wayfinder Studio Enterprise</title>
    
    <!-- React (UMD) - MUST BE FIRST TO DEFINE GLOBAL 'React' and 'ReactDOM' -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Tailwind CSS & Configuration -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    colors: { brand: { 500: '#3b82f6', 600: '#2563eb', 700: '#1d4ed8' } }
                }
            }
        }
    </script>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <!-- Babel (Needed to process JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- FIREBASE V9 MODULES via ESM Shim -->
    <script type="importmap">
        {
            "imports": {
                "firebase/app": "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js",
                "firebase/firestore": "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js",
                "firebase/auth": "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js"
            }
        }
    </script>

    <script type="module">
        import { initializeApp } from "firebase/app";
        import { getFirestore, doc, setDoc, getDoc, getDocs, deleteDoc, collection, query, where, serverTimestamp } from "firebase/firestore";
        import { getAuth, onAuthStateChanged } from "firebase/auth";

        // --- YOUR CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyDWJ5qVnsA3rWvfkc0-_cIyfwLHEZNMuxE",
            authDomain: "wayfinder-app-a2565.firebaseapp.com",
            projectId: "wayfinder-app-a2565",
            storageBucket: "wayfinder-app-a2565.firebasestorage.app",
            messagingSenderId: "770872636942",
            appId: "1:770872636942:web:f342a0d96de313a19a6e5f",
            measurementId: "G-W7BXXBPLGX"
        };

        try {
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            const auth = getAuth(app);

            // Expose to Window for React
            window.db = db;
            window.auth = auth;
            window.setDoc = setDoc;
            window.getDoc = getDoc;
            window.getDocs = getDocs;
            window.deleteDoc = deleteDoc;
            window.doc = doc;
            window.collection = collection;
            window.query = query;
            window.where = where;
            window.serverTimestamp = serverTimestamp;
            
            window.IMGBB_API_KEY = "d3c464ab1b35134225f0bf7787c09d16";
            
            // Critical: Listen for Auth State to trigger app rendering
            onAuthStateChanged(auth, (user) => {
                window.dispatchEvent(new CustomEvent('firebase-auth-initialized', { detail: user }));
            });

        } catch (err) {
            console.error("Firebase Init Error", err);
        }
    </script>

    <style>
        body { background-color: #f1f5f9; overflow: hidden; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .cursor-pan { cursor: grab; }
        .cursor-panning { cursor: grabbing; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.2s ease-out forwards; }
        .path-line { stroke-dasharray: 10; animation: dash 1s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -20; } }
        .nav-item.active { background-color: #e2e8f0; color: #2563eb; }
    </style>
</head>
<body>
    <div id="root" class="h-screen w-screen flex flex-col">
        <!-- Fallback for slow loading -->
        <div id="loading-fallback" class="h-full flex items-center justify-center text-slate-400">
            <i class="fas fa-spinner fa-spin text-4xl"></i>
            <span class="ml-3">Loading Studio...</span>
        </div>
    </div>

    <!-- MAIN APPLICATION SCRIPT - MOVED TO END OF BODY -->
    <script type="text/babel" data-presets="react,typescript">
        const { useState, useRef, useEffect, useCallback } = React;

        // --- AUTH HOOK ---
        function useAuthStatus() {
            const [user, setUser] = useState(null);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const handleAuthInit = (e) => {
                    setUser(e.detail);
                    setLoading(false);
                };
                window.addEventListener('firebase-auth-initialized', handleAuthInit);
                
                // Fallback for immediate auth status check
                if (window.auth) {
                    const unsubscribe = window.auth.onAuthStateChanged((u) => {
                        setUser(u);
                        setLoading(false);
                        window.removeEventListener('firebase-auth-initialized', handleAuthInit);
                    });
                    return () => unsubscribe();
                }

                return () => window.removeEventListener('firebase-auth-initialized', handleAuthInit);
            }, []);

            return { user, loading };
        }

        // --- CONSTANTS ---
        const CONFIG = {
            gridSize: 40, nodeRadius: 8, hitRadius: 15,
            colors: { selection: '#2563eb', path: '#10b981', walkable: '#64748b', destination: '#ef4444', kiosk: '#f59e0b', bathroom: '#8b5cf6', elevator: '#06b6d4', stairs: '#ec4899' }
        };
        const generateId = () => Math.random().toString(36).substr(2, 9);

        // --- SERVICES (Only database calls, helpers are local) ---
        async function uploadToImgBB(base64Image) {
            const formData = new FormData();
            const cleanBase64 = base64Image.split(',')[1];
            formData.append('image', cleanBase64);
            
            const response = await fetch(`https://api.imgbb.com/1/upload?key=${window.IMGBB_API_KEY}`, { method: 'POST', body: formData });
            const result = await response.json();
            if (result.success) return result.data.url;
            throw new Error(result.error ? result.error.message : 'Upload failed');
        }

        async function deployToKiosk(mapData, mapId, userId) {
            if (!window.db) throw new Error("Database not connected.");

            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error("Database connection timed out.")), 8000)
            );

            // 1. Save Map Data (Collection: users/{userId}/maps/{mapId})
            const saveMapPromise = window.setDoc(window.doc(window.db, "users", userId, "maps", mapId), {
                ...mapData, ownerId: userId, updatedAt: window.serverTimestamp()
            });
            await Promise.race([saveMapPromise, timeoutPromise]);
            
            // 2. Generate Pairing Code and Save (Collection: pairing_codes/{code})
            const code = Math.random().toString(36).substring(2, 8).toUpperCase();
            const saveCodePromise = window.setDoc(window.doc(window.db, "pairing_codes", code), {
                code: code, mapId: mapId, status: "waiting", createdAt: window.serverTimestamp(), ownerId: userId
            });

            await Promise.race([saveCodePromise, timeoutPromise]);
            return code;
        }
        
        async function syncUpdates(mapData, mapId, userId) {
            if (!window.db) throw new Error("Database not connected.");
            
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error("Database connection timed out.")), 8000)
            );

            // 1. Save Map Data (Update the existing document)
            const saveMapPromise = window.setDoc(window.doc(window.db, "users", userId, "maps", mapId), {
                ...mapData, ownerId: userId, updatedAt: window.serverTimestamp()
            });

            await Promise.race([saveMapPromise, timeoutPromise]);
        }


        // --- COMPONENTS ---

        const Icon = ({ name, className = '' }) => <i className={`fas fa-${name} ${className}`}></i>;

        const ToolButton = ({ active, icon, label, onClick }) => (
            <button onClick={onClick} className={`w-10 h-10 rounded-lg flex items-center justify-center transition-all ${active ? 'bg-brand-600 text-white shadow-inner' : 'bg-white text-slate-600 hover:bg-slate-50 border border-slate-200'}`} title={label}>
                <Icon name={icon} />
            </button>
        );

        const NavButton = ({ active, icon, label, onClick }) => (
            <button onClick={onClick} className={`w-full p-3 flex flex-col items-center justify-center transition-colors ${active ? 'text-brand-600 bg-brand-50 border-r-2 border-brand-600' : 'text-slate-500 hover:bg-slate-50'}`}>
                <Icon name={icon} className="text-xl mb-1" />
                <span className="text-[10px] font-medium">{label}</span>
            </button>
        );

        const DeployModal = ({ isOpen, onClose, code, isLoading, progress }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-slate-900/60 z-[100] flex items-center justify-center backdrop-blur-sm animate-fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl p-8 w-96 text-center">
                        <div className={`w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4 text-2xl ${isLoading ? 'bg-blue-100 text-blue-600' : 'bg-green-100 text-green-600'}`}>
                            <Icon name={isLoading ? "spinner" : "check"} className={isLoading ? "fa-spin" : ""} />
                        </div>
                        <h2 className="xl font-bold text-slate-800 mb-2">{isLoading ? 'Deploying...' : 'Connect Kiosk'}</h2>
                        {isLoading ? (
                            <p className="text-slate-500 text-sm">{progress}</p>
                        ) : (
                            <>
                                <p className="text-slate-500 text-sm mb-6">Enter this code on your Kiosk Player app to pair.</p>
                                <div className="bg-slate-100 border-2 border-dashed border-slate-300 rounded-lg p-4 mb-6">
                                    <span className="text-4xl font-mono font-bold tracking-widest text-slate-800">{code}</span>
                                </div>
                                <button onClick={onClose} className="w-full bg-slate-100 hover:bg-slate-200 text-slate-700 font-bold py-3 rounded-lg transition">Close</button>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        // --- SUB-PAGES ---

        const MapLibrary = ({ onEditMap, userId }) => {
            const [maps, setMaps] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const fetchMaps = async () => {
                    if (!userId) return;
                    setLoading(true);
                    try {
                        // Path: users/{userId}/maps
                        const mapsRef = window.collection(window.db, "users", userId, "maps");
                        const q = window.query(mapsRef, window.where("ownerId", "==", userId));
                        const snapshot = await window.getDocs(q);
                        const mapList = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setMaps(mapList);
                    } catch (e) { console.error("Map Fetch Error:", e); }
                    setLoading(false);
                };
                fetchMaps();
            }, [userId]);

            const deleteMap = async (id) => {
                if(!confirm("Are you sure? This will delete the map and break all associated pairings.")) return;
                try {
                    await window.deleteDoc(window.doc(window.db, "users", userId, "maps", id));
                    // Also attempt to delete any pairing codes pointing to this map ID (optional for cleanup)
                    const pairingQuery = window.query(window.collection(window.db, "pairing_codes"), window.where("mapId", "==", id));
                    const pairings = await window.getDocs(pairingQuery);
                    pairings.forEach(async (doc) => {
                        await window.deleteDoc(window.doc(window.db, "pairing_codes", doc.id));
                    });

                    setMaps(maps.filter(m => m.id !== id));
                } catch(e) { alert("Delete failed: " + e.message); }
            };

            if (loading) return <div className="p-8 text-center text-slate-500"><Icon name="spinner" className="fa-spin text-2xl" /> Loading Maps...</div>;

            return (
                <div className="p-8 h-full overflow-y-auto bg-slate-50">
                    <h1 className="text-2xl font-bold text-slate-800 mb-6">Map Library</h1>
                    {maps.length === 0 ? (
                        <div className="text-center p-10 bg-white rounded-xl shadow-sm border border-slate-200">
                            <Icon name="map" className="text-4xl text-slate-300 mb-4" />
                            <p className="text-slate-500">No maps saved yet. Go to Studio to create one.</p>
                        </div>
                    ) : (
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                            {maps.map(map => (
                                <div key={map.id} className="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden hover:shadow-md transition-shadow group">
                                    <div className="h-40 bg-slate-100 relative overflow-hidden">
                                        {map.metadata?.mapImage ? (
                                            <img src={map.metadata.mapImage} className="w-full h-full object-cover" onError={(e) => e.target.src = "https://placehold.co/400x200/cccccc/333333?text=Image+Missing"}/>
                                        ) : (
                                            <div className="w-full h-full flex items-center justify-center text-slate-300"><Icon name="image" className="text-3xl" /></div>
                                        )}
                                        <div className="absolute inset-0 bg-black/50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                                            <button onClick={() => onEditMap(map)} className="bg-white text-slate-900 px-4 py-2 rounded-full font-bold text-sm hover:bg-brand-50">Edit Map</button>
                                        </div>
                                    </div>
                                    <div className="p-4">
                                        <h3 className="font-bold text-slate-800 truncate">{map.metadata?.name || "Untitled Map"}</h3>
                                        <div className="flex justify-between items-center mt-2 text-xs text-slate-500">
                                            <span>{map.nodes?.length || 0} Nodes</span>
                                            <span>{map.updatedAt ? new Date(map.updatedAt.seconds * 1000).toLocaleDateString() : 'Draft'}</span>
                                        </div>
                                        <div className="mt-4 pt-3 border-t border-slate-100 flex justify-end">
                                            <button onClick={() => deleteMap(map.id)} className="text-red-500 hover:text-red-700 text-xs flex items-center gap-1"><Icon name="trash" /> Delete</button>
                                        </div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const DeviceManager = ({ userId }) => {
            const [devices, setDevices] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const fetchDevices = async () => {
                    if (!userId) return;
                    setLoading(true);
                    try {
                        // Fetch only pairings created by this user
                        const q = window.query(window.collection(window.db, "pairing_codes"), window.where("ownerId", "==", userId));
                        const snapshot = await window.getDocs(q);
                        const deviceList = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setDevices(deviceList); 
                    } catch (e) { console.error("Device Fetch Error:", e); }
                    setLoading(false);
                };
                fetchDevices();
            }, [userId]);

            const deleteDevice = async (id) => {
                if(!confirm("Revoke this connection? The kiosk will need to re-pair.")) return;
                try {
                    await window.deleteDoc(window.doc(window.db, "pairing_codes", id));
                    setDevices(devices.filter(d => d.id !== id));
                } catch(e) { alert("Error: " + e.message); }
            };

            if (loading) return <div className="p-8 text-center text-slate-500"><Icon name="spinner" className="fa-spin text-2xl" /> Loading Devices...</div>;

            return (
                <div className="p-8 h-full overflow-y-auto bg-slate-50">
                    <h1 className="text-2xl font-bold text-slate-800 mb-6">Device Management</h1>
                    <div className="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
                        <table className="w-full text-left text-sm">
                            <thead className="bg-slate-50 border-b border-slate-200 text-slate-500 uppercase text-xs">
                                <tr>
                                    <th className="p-4">Pairing Code</th>
                                    <th className="p-4">Linked Map ID</th>
                                    <th className="p-4">Status</th>
                                    <th className="p-4">Created</th>
                                    <th className="p-4 text-right">Actions</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-slate-100">
                                {devices.map(device => (
                                    <tr key={device.id} className="hover:bg-slate-50">
                                        <td className="p-4 font-mono font-bold text-brand-600">{device.code}</td>
                                        <td className="p-4 text-slate-600">{device.mapId}</td>
                                        <td className="p-4">
                                            <span className={`px-2 py-1 rounded-full text-xs font-medium ${device.status === 'active' ? 'bg-green-100 text-green-700' : 'bg-yellow-100 text-yellow-700'}`}>
                                                {device.status || 'Pending'}
                                            </span>
                                        </td>
                                        <td className="p-4 text-slate-500">{device.createdAt ? new Date(device.createdAt.seconds * 1000).toLocaleDateString() : '-'}</td>
                                        <td className="p-4 text-right">
                                            <button onClick={() => deleteDevice(device.id)} className="text-red-500 hover:bg-red-50 px-3 py-1.5 rounded transition">Revoke</button>
                                        </td>
                                    </tr>
                                ))}
                                {devices.length === 0 && (
                                    <tr><td colSpan="5" className="p-8 text-center text-slate-400">No active device pairings found.</td></tr>
                                )}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        const Editor = ({ initialData }) => {
            const userId = window.auth?.currentUser?.uid;
            
            // Core State (Linked to initialData if editing an old map)
            const [mapId] = useState(initialData?.id || `map_${generateId()}`);
            const [mapName, setMapName] = useState(initialData?.metadata?.name || "Untitled Project");
            const [nodes, setNodes] = useState(initialData?.nodes || []);
            const [edges, setEdges] = useState(initialData?.edges || []);
            const [mapImage, setMapImage] = useState(initialData?.metadata?.mapImage || null);
            
            const isCloudMap = !!initialData?.id; // True if loaded from Maps, False if new map

            // Deployment State
            const [showDeployModal, setShowDeployModal] = useState(false);
            const [deployCode, setDeployCode] = useState(null);
            const [isDeploying, setIsDeploying] = useState(false);
            const [isSyncing, setIsSyncing] = useState(false);
            const [uploadProgress, setUploadProgress] = useState('');

            // Canvas State
            const [toolMode, setToolMode] = useState('select');
            const [selectedId, setSelectedId] = useState(null);
            const [view, setView] = useState({ scale: 1, x: 0, y: 0 });
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const imgRef = useRef(null);
            const dragRef = useRef(null);
            const tempEdgeRef = useRef(null);

            // Init Image
            useEffect(() => {
                if (mapImage) {
                    const img = new Image();
                    img.src = mapImage;
                    img.onload = () => { imgRef.current = img; };
                }
            }, [mapImage]);

            // --- DEPLOYMENT LOGIC ---
            const prepareMapData = async (isNewDeployment) => {
                let finalUrl = mapImage;
                
                // Only upload image if it's a new deployment OR if the current URL is a local blob (meaning user changed/uploaded a new image)
                if (isNewDeployment || mapImage?.startsWith('data:')) {
                    setUploadProgress('Uploading Image to Cloud...');
                    finalUrl = await uploadToImgBB(mapImage);
                    setMapImage(finalUrl); 
                }
                
                return {
                    metadata: { version: "3.0", generated: new Date().toISOString(), mapImage: finalUrl, name: mapName },
                    nodes, edges
                };
            };

            const handleNewDeploy = async () => {
                if(!mapImage) { alert("Please upload a map first."); return; }
                setIsDeploying(true); setShowDeployModal(true); setDeployCode(null); setUploadProgress('Initializing...');
                try {
                    const data = await prepareMapData(true); // Forces image upload
                    setUploadProgress('Generating Code...');
                    const code = await deployToKiosk(data, mapId, userId);
                    setDeployCode(code);
                } catch (e) { alert("Deployment Failed: " + e.message); setShowDeployModal(false); }
                setIsDeploying(false);
            };

            const handleSyncUpdate = async () => {
                if(!mapImage) return;
                setIsSyncing(true);
                try {
                    const data = await prepareMapData(false); // Only uploads image if it's a local blob
                    await syncUpdates(data, mapId, userId);
                    alert("Sync successful! Changes are live on connected kiosks.");
                } catch (e) { alert("Sync failed: " + e.message); }
                setIsSyncing(false);
            };

            // --- CANVAS LOGIC (Kept minimal for consistency) ---
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const render = () => {
                    canvas.width = containerRef.current?.clientWidth || 800; canvas.height = containerRef.current?.clientHeight || 600;
                    ctx.clearRect(0,0,canvas.width,canvas.height); ctx.save();
                    ctx.translate(view.x, view.y); ctx.scale(view.scale, view.scale);
                    if (imgRef.current) {
                        ctx.drawImage(imgRef.current, 0, 0);
                        ctx.beginPath(); ctx.strokeStyle = 'rgba(0,0,0,0.05)'; ctx.lineWidth=1/view.scale;
                        for(let x=0; x<=imgRef.current.width; x+=CONFIG.gridSize) { ctx.moveTo(x,0); ctx.lineTo(x,imgRef.current.height); }
                        for(let y=0; y<=imgRef.current.height; y+=CONFIG.gridSize) { ctx.moveTo(0,y); ctx.lineTo(imgRef.current.width,y); }
                        ctx.stroke();
                    }
                    edges.forEach(e => {
                        const n1 = nodes.find(n=>n.id===e.from), n2 = nodes.find(n=>n.id===e.to);
                        if(n1 && n2) {
                            ctx.beginPath(); ctx.moveTo(n1.x, n1.y); ctx.lineTo(n2.x, n2.y);
                            ctx.strokeStyle = selectedId === e.id ? CONFIG.colors.selection : '#94a3b8';
                            ctx.lineWidth = (selectedId === e.id ? 4 : 2) / view.scale;
                            ctx.stroke();
                        }
                    });
                    nodes.forEach(n => {
                        const isSel = selectedId === n.id;
                        ctx.beginPath(); ctx.arc(n.x, n.y, (isSel ? 12 : 8)/view.scale, 0, Math.PI*2);
                        ctx.fillStyle = CONFIG.colors[n.type] || CONFIG.colors.walkable; ctx.fill();
                        if(isSel) { ctx.strokeStyle = '#fff'; ctx.lineWidth=2/view.scale; ctx.stroke(); }
                    });
                    ctx.restore();
                    requestAnimationFrame(render);
                };
                render();
            }, [nodes, edges, view, selectedId, mapImage]);

            const toWorld = (mx, my) => ({ x: (mx - view.x) / view.scale, y: (my - view.y) / view.scale });

            const handleMouseDown = (e) => {
                const rect = containerRef.current.getBoundingClientRect();
                const mx = e.clientX - rect.left, my = e.clientY - rect.top;
                const wPos = toWorld(mx, my);
                const hitNode = nodes.find(n => Math.hypot(n.x - wPos.x, n.y - wPos.y) < 15/view.scale);

                if (toolMode === 'pan' || e.button === 1) { dragRef.current = { type: 'pan', sx: mx, sy: my, vStart: {...view} }; return; }
                
                if (toolMode === 'select') { if (hitNode) { setSelectedId(hitNode.id); dragRef.current = { type: 'move', id: hitNode.id }; } else setSelectedId(null); }
                else if (toolMode === 'node') { if (hitNode) setSelectedId(hitNode.id);
                else { const id = generateId(); setNodes([...nodes, { id, x: wPos.x, y: wPos.y, type: 'walkable', name: '' }]); setSelectedId(id); } }
                else if (toolMode === 'edge' && hitNode) tempEdgeRef.current = { start: hitNode.id, curr: wPos };
            };
            const handleMouseMove = (e) => {
                const rect = containerRef.current.getBoundingClientRect();
                const mx = e.clientX - rect.left, my = e.clientY - rect.top;
                const wPos = { x: (mx - view.x)/view.scale, y: (my - view.y)/view.scale };

                if (dragRef.current?.type === 'pan') { setView({ ...view, x: dragRef.current.vStart.x + (mx - dragRef.current.sx), y: dragRef.current.vStart.y + (my - dragRef.current.sy) }); }
                else if (dragRef.current?.type === 'move') { setNodes(nodes.map(n => n.id === dragRef.current.id ? { ...n, x: wPos.x, y: wPos.y } : n)); }
                else if (tempEdgeRef.current) tempEdgeRef.current.curr = wPos;
            };
            const handleMouseUp = (e) => {
                if (tempEdgeRef.current) {
                    const rect = containerRef.current.getBoundingClientRect();
                    const wPos = { x: (e.clientX - rect.left - view.x)/view.scale, y: (e.clientY - rect.top - view.y)/view.scale };
                    const hitNode = nodes.find(n => Math.hypot(n.x - wPos.x, n.y - wPos.y) < 15/view.scale);
                    if (hitNode && hitNode.id !== tempEdgeRef.current.start) {
                        setEdges([...edges, { id: generateId(), from: tempEdgeRef.current.start, to: hitNode.id, weight: 1, accessible: true }]);
                    }
                    tempEdgeRef.current = null;
                }
                dragRef.current = null;
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if(file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const img = new Image(); img.src = evt.target.result;
                        img.onload = () => {
                            imgRef.current = img; setMapImage(evt.target.result);
                            setView({ scale: Math.min((containerRef.current.clientWidth-40)/img.width, (containerRef.current.clientHeight-40)/img.height), x: 20, y: 20 });
                        }
                    };
                    reader.readAsDataURL(file);
                }
            };

            const selectedElement = nodes.find(n => n.id === selectedId) || edges.find(e => e.id === selectedId);


            return (
                <div className="flex flex-col h-full bg-white">
                    <div className="h-14 border-b border-slate-200 flex items-center justify-between px-4 shrink-0">
                        <div className="flex items-center gap-2">
                            <input value={mapName} onChange={(e) => setMapName(e.target.value)} className="font-bold text-slate-800 bg-transparent border border-transparent hover:border-slate-300 px-2 py-1 rounded transition focus:border-brand-500 outline-none" />
                            {isCloudMap && <span className="text-[10px] bg-blue-50 text-brand-600 px-2 py-0.5 rounded-full font-medium">Map ID: {mapId}</span>}
                        </div>
                        <div className="flex gap-2">
                            {isCloudMap ? (
                                <button onClick={handleSyncUpdate} disabled={isSyncing} className="px-4 py-1.5 text-xs font-medium bg-blue-50 text-blue-600 hover:bg-blue-100 border border-blue-200 rounded transition flex items-center gap-2">
                                    <Icon name={isSyncing ? "spinner" : "sync"} className={isSyncing ? "fa-spin" : ""} />
                                    {isSyncing ? "Syncing..." : "Sync Updates"}
                                </button>
                            ) : (
                                <button onClick={()=>{
                                    if(!mapImage) { alert("Please upload a map image first."); return; }
                                    if(nodes.length < 2) { alert("Please add at least 2 nodes and 1 edge."); return; }
                                    handleNewDeploy();
                                }} className="px-4 py-1.5 text-xs font-medium bg-green-600 hover:bg-green-700 text-white rounded shadow flex items-center gap-2">
                                    <Icon name="qrcode" /> Save & Connect
                                </button>
                            )}
                            
                        </div>
                    </div>

                    <div className="flex-1 flex overflow-hidden">
                        <div className="w-14 border-r border-slate-200 flex flex-col items-center py-4 gap-4 bg-slate-50">
                            <ToolButton icon="mouse-pointer" label="Select" active={toolMode==='select'} onClick={()=>setToolMode('select')} />
                            <ToolButton icon="circle-dot" label="Node" active={toolMode==='node'} onClick={()=>setToolMode('node')} />
                            <ToolButton icon="draw-polygon" label="Edge" active={toolMode==='edge'} onClick={()=>setToolMode('edge')} />
                            <ToolButton icon="hand" label="Pan" active={toolMode==='pan'} onClick={()=>setToolMode('pan')} />
                            <div className="h-px w-8 bg-slate-200"></div>
                            <label className="w-10 h-10 rounded-lg flex items-center justify-center bg-white text-slate-600 hover:bg-slate-50 border border-slate-200 cursor-pointer" title="Upload Map">
                                <Icon name="image" /> <input type="file" onChange={handleImageUpload} className="hidden" accept="image/*" />
                            </label>
                        </div>

                        <div className="flex-1 relative bg-slate-100 overflow-hidden cursor-pan" ref={containerRef} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onWheel={(e)=>{setView({...view, scale: Math.max(0.1, view.scale*(1-e.deltaY*0.001))})}}>
                            <canvas ref={canvasRef} className="block" />
                            {!mapImage && <div className="absolute inset-0 flex items-center justify-center pointer-events-none"><div className="bg-white/80 p-6 rounded-xl shadow-lg text-center backdrop-blur"><div className="text-4xl mb-2">üó∫Ô∏è</div><p className="text-slate-600 font-medium">Upload a map image to start</p></div></div>}
                        </div>

                        <div className="w-72 bg-white border-l border-slate-200 flex flex-col shadow-xl">
                            <div className="h-10 bg-slate-50 border-b flex items-center px-4 text-xs font-bold text-slate-500 uppercase">Properties</div>
                            <div className="p-4 flex-1 overflow-y-auto">
                                {selectedElement ? (
                                    <div className="space-y-4">
                                        {selectedElement.hasOwnProperty('name') ? (
                                            <>
                                                <div><label className="block text-xs font-medium text-slate-500 mb-1">Name</label><input type="text" value={selectedElement.name} onChange={e => setNodes(nodes.map(n => n.id === selectedId ? {...n, name: e.target.value} : n))} className="w-full border rounded p-2 text-sm" placeholder="Location Name" /></div>
                                                <div><label className="block text-xs font-medium text-slate-500 mb-1">Type</label><select value={selectedElement.type} onChange={e => setNodes(nodes.map(n => n.id === selectedId ? {...n, type: e.target.value} : n))} className="w-full border rounded p-2 text-sm bg-white">{Object.keys(CONFIG.colors).map(t => <option key={t} value={t}>{t}</option>)}</select></div>
                                                <button onClick={() => { setNodes(nodes.filter(n => n.id !== selectedId)); setEdges(edges.filter(e => e.from !== selectedId && e.to !== selectedId)); setSelectedId(null); }} className="w-full bg-red-50 text-red-600 py-2 rounded text-xs font-bold mt-4">Delete Node</button>
                                            </>
                                        ) : (
                                            <>
                                                <div><label className="block text-xs font-medium text-slate-500 mb-1">Weight</label><input type="number" value={selectedElement.weight} onChange={e => setEdges(edges.map(ed => ed.id === selectedId ? {...ed, weight: parseInt(e.target.value)} : ed))} className="w-full border rounded p-2 text-sm" /></div>
                                                <button onClick={() => { setEdges(edges.filter(e => e.id !== selectedId)); setSelectedId(null); }} className="w-full bg-red-50 text-red-600 py-2 rounded text-xs font-bold mt-4">Delete Edge</button>
                                            </>
                                        )}
                                    </div>
                                ) : <div className="text-center text-slate-400 text-sm mt-10">Select an element to edit</div>}
                            </div>
                        </div>
                    </div>
                    <DeployModal isOpen={showDeployModal} onClose={() => setShowDeployModal(false)} code={deployCode} isLoading={isDeploying} progress={uploadProgress} />
                </div>
            );
        };

        const LoginRequired = () => (
            <div className="h-full flex items-center justify-center bg-slate-100">
                <div className="text-center p-10 bg-white rounded-xl shadow-lg border border-slate-200 max-w-sm">
                    <div className="w-16 h-16 bg-red-100 text-red-600 rounded-full flex items-center justify-center mx-auto mb-4">
                        <Icon name="lock" className="text-3xl" />
                    </div>
                    <h2 className="text-2xl font-bold mb-2">Access Denied</h2>
                    <p className="text-slate-600 mb-6">You must be logged in via the landing page to access the studio dashboard.</p>
                    <button 
                        onClick={() => { 
                            // Simulate returning to landing page (assuming it's named index.html)
                            try { window.location.href = 'index.html'; } catch (e) { alert("Please log in on the main landing page first."); }
                        }}
                        className="w-full py-3 bg-brand-600 text-white rounded-lg font-bold hover:bg-brand-700 transition"
                    >
                        Go to Login Page
                    </button>
                </div>
            </div>
        );


        const App = () => {
            const { user, loading } = useAuthStatus();
            const [view, setView] = useState('studio');
            const [currentMapData, setCurrentMapData] = useState(null);

            const handleEditMap = (mapData) => {
                setCurrentMapData(mapData);
                setView('studio');
            };
            
            if (loading) {
                 // Remove the temporary loading fallback from the DOM once React starts
                if (document.getElementById('loading-fallback')) {
                    document.getElementById('loading-fallback').style.display = 'none';
                }
                return (
                    <div className="h-full flex items-center justify-center text-slate-500">
                        <Icon name="spinner" className="fa-spin text-4xl" />
                    </div>
                );
            }

            if (!user) {
                 // Remove the temporary loading fallback from the DOM once React starts
                if (document.getElementById('loading-fallback')) {
                    document.getElementById('loading-fallback').style.display = 'none';
                }
                return <LoginRequired />;
            }
            
            // Rendered only if user is logged in
            return (
                <div className="flex h-full font-sans text-slate-800">
                    <div className="w-20 bg-slate-900 flex flex-col items-center py-6 gap-6 text-slate-400 z-50">
                        <div className="w-10 h-10 bg-gradient-to-br from-brand-500 to-brand-700 rounded-lg flex items-center justify-center text-white font-bold text-xl shadow-lg mb-4">W</div>
                        <NavButton active={view === 'studio'} icon="pen-nib" label="Studio" onClick={() => { setView('studio'); setCurrentMapData(null); }} />
                        <NavButton active={view === 'maps'} icon="map" label="Maps" onClick={() => setView('maps')} />
                        <NavButton active={view === 'devices'} icon="tablet-alt" label="Devices" onClick={() => setView('devices')} />
                    </div>
                    <div className="flex-1 bg-slate-100 overflow-hidden relative">
                        {view === 'studio' && <Editor initialData={currentMapData} key={currentMapData ? currentMapData.id : 'new'} />}
                        {view === 'maps' && <MapLibrary onEditMap={handleEditMap} userId={user.uid} />}
                        {view === 'devices' && <DeviceManager userId={user.uid} />}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

