<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wayfinder Studio Enterprise</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <!-- React (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    colors: { brand: { 500: '#3b82f6', 600: '#2563eb', 700: '#1d4ed8' } }
                }
            }
        }
    </script>

    <!-- FIREBASE V9 MODULES via ESM Shim -->
    <script type="importmap">
        {
            "imports": {
                "firebase/app": "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js",
                "firebase/firestore": "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js"
            }
        }
    </script>

    <script type="module">
        import { initializeApp } from "firebase/app";
        import { getFirestore, doc, setDoc, serverTimestamp } from "firebase/firestore";

        // --- YOUR CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyDWJ5qVnsA3rWvfkc0-_cIyfwLHEZNMuxE",
            authDomain: "wayfinder-app-a2565.firebaseapp.com",
            projectId: "wayfinder-app-a2565",
            storageBucket: "wayfinder-app-a2565.firebasestorage.app",
            messagingSenderId: "770872636942",
            appId: "1:770872636942:web:f342a0d96de313a19a6e5f",
            measurementId: "G-W7BXXBPLGX"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Expose to Window for React
        window.db = db;
        window.setDoc = setDoc;
        window.doc = doc;
        window.serverTimestamp = serverTimestamp;
        window.IMGBB_API_KEY = "d3c464ab1b35134225f0bf7787c09d16";
    </script>

    <style>
        body { background-color: #f1f5f9; overflow: hidden; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .cursor-pan { cursor: grab; }
        .cursor-panning { cursor: grabbing; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.2s ease-out forwards; }
        .path-line { stroke-dasharray: 10; animation: dash 1s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -20; } }
    </style>
</head>
<body>
    <div id="root" class="h-screen w-screen flex flex-col"></div>

    <script type="text/babel" data-presets="react,typescript">
        const { useState, useRef, useEffect, useCallback } = React;

        // --- CONSTANTS ---
        const CONFIG = {
            gridSize: 40, nodeRadius: 8, hitRadius: 15,
            colors: { selection: '#2563eb', path: '#10b981', walkable: '#64748b', destination: '#ef4444', kiosk: '#f59e0b', bathroom: '#8b5cf6', elevator: '#06b6d4', stairs: '#ec4899' }
        };
        const generateId = () => Math.random().toString(36).substr(2, 9);

        // --- SERVICES (Moved from your previous code) ---
        
        async function uploadToImgBB(base64Image) {
            const formData = new FormData();
            const cleanBase64 = base64Image.split(',')[1];
            formData.append('image', cleanBase64);
            
            const response = await fetch(`https://api.imgbb.com/1/upload?key=${window.IMGBB_API_KEY}`, {
                method: 'POST', body: formData
            });
            const result = await response.json();
            if (result.success) return result.data.url;
            throw new Error(result.error ? result.error.message : 'Upload failed');
        }

        async function deployToKiosk(mapData, mapId) {
            // 1. Save Map Data
            await window.setDoc(window.doc(window.db, "maps", mapId), mapData);
            
            // 2. Generate Pairing Code
            const code = Math.random().toString(36).substring(2, 8).toUpperCase();
            
            // 3. Save Code
            await window.setDoc(window.doc(window.db, "pairing_codes", code), {
                code: code,
                mapId: mapId,
                status: "waiting",
                createdAt: window.serverTimestamp()
            });
            
            return code;
        }

        // --- COMPONENTS ---

        const Icon = ({ name, className = '' }) => <i className={`fas fa-${name} ${className}`}></i>;

        const ToolButton = ({ active, icon, label, onClick }) => (
            <button onClick={onClick} className={`w-10 h-10 rounded-lg flex items-center justify-center transition-all ${active ? 'bg-brand-600 text-white shadow-inner' : 'bg-white text-slate-600 hover:bg-slate-50 border border-slate-200'}`} title={label}>
                <Icon name={icon} />
            </button>
        );

        const DeployModal = ({ isOpen, onClose, code, isLoading }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-slate-900/60 z-50 flex items-center justify-center backdrop-blur-sm animate-fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl p-8 w-96 text-center">
                        <div className="w-16 h-16 bg-brand-100 text-brand-600 rounded-full flex items-center justify-center mx-auto mb-4 text-2xl">
                            <Icon name={isLoading ? "spinner" : "mobile-alt"} className={isLoading ? "fa-spin" : ""} />
                        </div>
                        <h2 className="text-xl font-bold text-slate-800 mb-2">{isLoading ? 'Deploying...' : 'Connect Kiosk'}</h2>
                        
                        {isLoading ? (
                            <p className="text-slate-500 text-sm">Uploading assets and generating code...</p>
                        ) : (
                            <>
                                <p className="text-slate-500 text-sm mb-6">Enter this code on your Kiosk Player app to download this map.</p>
                                <div className="bg-slate-100 border-2 border-dashed border-slate-300 rounded-lg p-4 mb-6">
                                    <span className="text-4xl font-mono font-bold tracking-widest text-slate-800">{code}</span>
                                </div>
                                <button onClick={onClose} className="w-full bg-slate-100 hover:bg-slate-200 text-slate-700 font-bold py-3 rounded-lg transition">Close</button>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        const App = () => {
            // State
            const [mapId] = useState(`map_${Date.now()}`);
            const [nodes, setNodes] = useState([]);
            const [edges, setEdges] = useState([]);
            const [mapImage, setMapImage] = useState(null); // URL (remote or local blob)
            const [toolMode, setToolMode] = useState('select');
            const [selectedId, setSelectedId] = useState(null);
            const [view, setView] = useState({ scale: 1, x: 0, y: 0 });
            
            // Deployment State
            const [showDeployModal, setShowDeployModal] = useState(false);
            const [deployCode, setDeployCode] = useState(null);
            const [isDeploying, setIsDeploying] = useState(false);
            const [uploadProgress, setUploadProgress] = useState('');

            // Refs
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const imgRef = useRef(null);
            const dragRef = useRef(null);
            const tempEdgeRef = useRef(null);

            // --- CANVAS LOGIC ---
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                
                const render = () => {
                    canvas.width = containerRef.current?.clientWidth || 800;
                    canvas.height = containerRef.current?.clientHeight || 600;
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.save();
                    ctx.translate(view.x, view.y);
                    ctx.scale(view.scale, view.scale);

                    // Image
                    if (imgRef.current) {
                        ctx.drawImage(imgRef.current, 0, 0);
                        // Grid
                        ctx.beginPath();
                        ctx.strokeStyle = 'rgba(0,0,0,0.05)';
                        ctx.lineWidth = 1/view.scale;
                        for(let x=0; x<=imgRef.current.width; x+=CONFIG.gridSize) { ctx.moveTo(x,0); ctx.lineTo(x,imgRef.current.height); }
                        for(let y=0; y<=imgRef.current.height; y+=CONFIG.gridSize) { ctx.moveTo(0,y); ctx.lineTo(imgRef.current.width,y); }
                        ctx.stroke();
                    }

                    // Edges
                    edges.forEach(e => {
                        const n1 = nodes.find(n => n.id === e.from);
                        const n2 = nodes.find(n => n.id === e.to);
                        if(n1 && n2) {
                            const isSel = selectedId === e.id;
                            ctx.beginPath();
                            ctx.moveTo(n1.x, n1.y);
                            ctx.lineTo(n2.x, n2.y);
                            ctx.strokeStyle = isSel ? CONFIG.colors.selection : '#94a3b8';
                            ctx.lineWidth = (isSel ? 4 : 2) / view.scale;
                            ctx.stroke();
                        }
                    });

                    // Temp Edge
                    if (tempEdgeRef.current) {
                        const n1 = nodes.find(n => n.id === tempEdgeRef.current.start);
                        if(n1) {
                            ctx.beginPath();
                            ctx.moveTo(n1.x, n1.y);
                            ctx.lineTo(tempEdgeRef.current.curr.x, tempEdgeRef.current.curr.y);
                            ctx.strokeStyle = CONFIG.colors.selection;
                            ctx.setLineDash([5,5]);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                    }

                    // Nodes
                    nodes.forEach(n => {
                        const isSel = selectedId === n.id;
                        ctx.beginPath();
                        ctx.arc(n.x, n.y, (isSel ? 12 : 8)/view.scale, 0, Math.PI*2);
                        ctx.fillStyle = CONFIG.colors[n.type] || CONFIG.colors.walkable;
                        ctx.fill();
                        if(isSel) { ctx.strokeStyle = '#fff'; ctx.lineWidth=2/view.scale; ctx.stroke(); }
                        
                        if(n.name) {
                            ctx.font = `600 ${12/view.scale}px Inter`;
                            ctx.fillStyle = '#1e293b';
                            ctx.textAlign = 'center';
                            ctx.fillText(n.name, n.x, n.y - 15/view.scale);
                        }
                    });

                    ctx.restore();
                    requestAnimationFrame(render);
                };
                render();
            }, [nodes, edges, view, selectedId, mapImage]);

            // --- HANDLERS ---

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if(file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const img = new Image();
                        img.src = evt.target.result;
                        img.onload = () => {
                            imgRef.current = img;
                            setMapImage(evt.target.result); // Initially local Data URL
                            // Fit view
                            const scale = Math.min((containerRef.current.clientWidth-40)/img.width, (containerRef.current.clientHeight-40)/img.height);
                            setView({ scale, x: 20, y: 20 });
                        }
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleDeploy = async () => {
                if(!mapImage) { alert("Please upload a map first."); return; }
                setIsDeploying(true);
                setShowDeployModal(true);
                setUploadProgress('Preparing...');

                try {
                    let finalUrl = mapImage;
                    
                    // Check if local blob/base64, if so, upload to ImgBB
                    if (mapImage.startsWith('data:')) {
                        setUploadProgress('Uploading Image...');
                        finalUrl = await uploadToImgBB(mapImage);
                        setMapImage(finalUrl); // Update state to remote URL
                    }

                    setUploadProgress('Generating Code...');
                    const mapData = {
                        metadata: { version: "2.1", generated: new Date().toISOString(), mapImage: finalUrl },
                        nodes,
                        edges
                    };

                    const code = await deployToKiosk(mapData, mapId);
                    setDeployCode(code);
                } catch (err) {
                    alert("Deployment Error: " + err.message);
                    setShowDeployModal(false);
                } finally {
                    setIsDeploying(false);
                }
            };

            const toWorld = (mx, my) => ({
                x: (mx - view.x) / view.scale,
                y: (my - view.y) / view.scale
            });

            const handleMouseDown = (e) => {
                const rect = containerRef.current.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const wPos = toWorld(mx, my);
                
                const hitNode = nodes.find(n => Math.hypot(n.x - wPos.x, n.y - wPos.y) < 15/view.scale);

                if (toolMode === 'pan' || e.button === 1) {
                    dragRef.current = { type: 'pan', sx: mx, sy: my, vStart: {...view} };
                    return;
                }

                if (toolMode === 'select') {
                    if (hitNode) {
                        setSelectedId(hitNode.id);
                        dragRef.current = { type: 'move', id: hitNode.id };
                    } else {
                        setSelectedId(null);
                    }
                } else if (toolMode === 'node') {
                    if (hitNode) {
                        setSelectedId(hitNode.id);
                    } else {
                        const id = generateId();
                        setNodes([...nodes, { id, x: wPos.x, y: wPos.y, type: 'walkable', name: '' }]);
                        setSelectedId(id);
                    }
                } else if (toolMode === 'edge') {
                    if (hitNode) {
                        tempEdgeRef.current = { start: hitNode.id, curr: wPos };
                    }
                }
            };

            const handleMouseMove = (e) => {
                const rect = containerRef.current.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const wPos = toWorld(mx, my);

                if (dragRef.current?.type === 'pan') {
                    setView({
                        ...view,
                        x: dragRef.current.vStart.x + (mx - dragRef.current.sx),
                        y: dragRef.current.vStart.y + (my - dragRef.current.sy)
                    });
                } else if (dragRef.current?.type === 'move') {
                    setNodes(nodes.map(n => n.id === dragRef.current.id ? { ...n, x: wPos.x, y: wPos.y } : n));
                } else if (tempEdgeRef.current) {
                    tempEdgeRef.current.curr = wPos;
                }
            };

            const handleMouseUp = (e) => {
                if (tempEdgeRef.current) {
                    const rect = containerRef.current.getBoundingClientRect();
                    const wPos = toWorld(e.clientX - rect.left, e.clientY - rect.top);
                    const hitNode = nodes.find(n => Math.hypot(n.x - wPos.x, n.y - wPos.y) < 15/view.scale);
                    
                    if (hitNode && hitNode.id !== tempEdgeRef.current.start) {
                        setEdges([...edges, { id: generateId(), from: tempEdgeRef.current.start, to: hitNode.id, weight: 1, accessible: true }]);
                    }
                    tempEdgeRef.current = null;
                }
                dragRef.current = null;
            };

            const selectedElement = nodes.find(n => n.id === selectedId) || edges.find(e => e.id === selectedId);

            return (
                <div className="flex flex-col h-full text-slate-800 font-sans">
                    {/* HEADER */}
                    <div className="h-14 bg-white border-b border-slate-200 flex items-center justify-between px-4 z-20 shadow-sm">
                        <div className="flex items-center gap-3">
                            <div className="bg-brand-600 text-white w-8 h-8 rounded flex items-center justify-center font-bold">W</div>
                            <h1 className="font-semibold text-slate-800">Wayfinder Studio</h1>
                        </div>
                        <div className="flex gap-2">
                            <button onClick={() => {
                                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify({metadata: {mapImage: mapImage?.startsWith('data') ? null : mapImage}, nodes, edges}));
                                const dl = document.createElement('a'); dl.setAttribute("href", dataStr); dl.setAttribute("download", "map.json"); dl.click();
                            }} className="px-3 py-1.5 text-xs font-medium border rounded hover:bg-slate-50">Export JSON</button>
                            
                            <button 
                                onClick={handleDeploy}
                                className="px-4 py-1.5 text-xs font-medium bg-green-600 hover:bg-green-700 text-white rounded shadow flex items-center gap-2"
                            >
                                <Icon name="qrcode" /> Connect Kiosk
                            </button>
                        </div>
                    </div>

                    <div className="flex-1 flex overflow-hidden">
                        {/* SIDEBAR */}
                        <div className="w-16 bg-white border-r border-slate-200 flex flex-col items-center py-4 gap-4 z-10">
                            <ToolButton icon="mouse-pointer" label="Select" active={toolMode==='select'} onClick={()=>setToolMode('select')} />
                            <ToolButton icon="circle-dot" label="Node" active={toolMode==='node'} onClick={()=>setToolMode('node')} />
                            <ToolButton icon="draw-polygon" label="Edge" active={toolMode==='edge'} onClick={()=>setToolMode('edge')} />
                            <ToolButton icon="hand" label="Pan" active={toolMode==='pan'} onClick={()=>setToolMode('pan')} />
                            <div className="h-px w-8 bg-slate-200"></div>
                            <label className="w-10 h-10 rounded-lg flex items-center justify-center bg-white text-slate-600 hover:bg-slate-50 border border-slate-200 cursor-pointer" title="Upload Map">
                                <Icon name="image" />
                                <input type="file" onChange={handleImageUpload} className="hidden" accept="image/*" />
                            </label>
                        </div>

                        {/* CANVAS */}
                        <div className="flex-1 relative bg-slate-100 overflow-hidden cursor-pan" 
                             ref={containerRef}
                             onMouseDown={handleMouseDown}
                             onMouseMove={handleMouseMove}
                             onMouseUp={handleMouseUp}
                             onWheel={(e) => {
                                 const sc = Math.max(0.1, view.scale * (1 - e.deltaY * 0.001));
                                 setView({...view, scale: sc});
                             }}
                        >
                            <canvas ref={canvasRef} className="block" />
                            {!mapImage && (
                                <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                                    <div className="bg-white/80 p-6 rounded-xl shadow-lg text-center backdrop-blur">
                                        <div className="text-4xl mb-2">üó∫Ô∏è</div>
                                        <p className="text-slate-600 font-medium">Upload a map image to start</p>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* PROPERTIES PANEL */}
                        <div className="w-72 bg-white border-l border-slate-200 shadow-xl flex flex-col">
                            <div className="h-10 bg-slate-50 border-b flex items-center px-4 text-xs font-bold text-slate-500 uppercase">Properties</div>
                            <div className="p-4 flex-1 overflow-y-auto">
                                {selectedId && selectedElement ? (
                                    <div className="space-y-4">
                                        {selectedElement.hasOwnProperty('name') ? (
                                            <>
                                                <div>
                                                    <label className="block text-xs font-medium text-slate-500 mb-1">Name</label>
                                                    <input type="text" value={selectedElement.name} onChange={e => setNodes(nodes.map(n => n.id === selectedId ? {...n, name: e.target.value} : n))} className="w-full border rounded p-2 text-sm" placeholder="Location Name" />
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-slate-500 mb-1">Type</label>
                                                    <select value={selectedElement.type} onChange={e => setNodes(nodes.map(n => n.id === selectedId ? {...n, type: e.target.value} : n))} className="w-full border rounded p-2 text-sm bg-white">
                                                        {Object.keys(CONFIG.colors).map(t => <option key={t} value={t}>{t}</option>)}
                                                    </select>
                                                </div>
                                                <button onClick={() => { setNodes(nodes.filter(n => n.id !== selectedId)); setEdges(edges.filter(e => e.from !== selectedId && e.to !== selectedId)); setSelectedId(null); }} className="w-full bg-red-50 text-red-600 py-2 rounded text-xs font-bold mt-4">Delete Node</button>
                                            </>
                                        ) : (
                                            <>
                                                <div>
                                                    <label className="block text-xs font-medium text-slate-500 mb-1">Weight</label>
                                                    <input type="number" value={selectedElement.weight} onChange={e => setEdges(edges.map(ed => ed.id === selectedId ? {...ed, weight: parseInt(e.target.value)} : ed))} className="w-full border rounded p-2 text-sm" />
                                                </div>
                                                <button onClick={() => { setEdges(edges.filter(e => e.id !== selectedId)); setSelectedId(null); }} className="w-full bg-red-50 text-red-600 py-2 rounded text-xs font-bold mt-4">Delete Edge</button>
                                            </>
                                        )}
                                    </div>
                                ) : (
                                    <div className="text-center text-slate-400 text-sm mt-10">Select an element to edit</div>
                                )}
                            </div>
                            <div className="p-3 bg-slate-50 border-t text-xs text-slate-500 flex justify-between">
                                <span>Nodes: {nodes.length}</span>
                                <span>Edges: {edges.length}</span>
                            </div>
                        </div>
                    </div>

                    <DeployModal 
                        isOpen={showDeployModal} 
                        onClose={() => setShowDeployModal(false)} 
                        code={deployCode} 
                        isLoading={isDeploying} 
                    />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
